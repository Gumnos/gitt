<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Git In the Trenches</TITLE>
<META NAME="description" CONTENT="Git In the Trenches">
<META NAME="keywords" CONTENT="gitt">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="gitt.css">

</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<P>
 =1000
=1000

<P>
<H1 ALIGN="CENTER">Git In the Trenches</H1>
<DIV CLASS="author_info">

<P ALIGN="CENTER"><STRONG>Peter Savage</STRONG></P>
<P ALIGN="CENTER"><STRONG>Feburary 2011</STRONG></P>
</DIV>

<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html65"
  HREF="gitt.html#SECTION00200000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html66"
  HREF="gitt.html#SECTION00210000000000000000">How this book works</A>
</UL>
<BR>
<LI><A NAME="tex2html67"
  HREF="gitt.html#SECTION00300000000000000000">Week 1</A>
<UL>
<LI><A NAME="tex2html68"
  HREF="gitt.html#SECTION00310000000000000000">Day 1 - ``Things need to change''</A>
<UL>
<LI><A NAME="tex2html69"
  HREF="gitt.html#SECTION00311000000000000000">Meeting the Team</A>
<LI><A NAME="tex2html70"
  HREF="gitt.html#SECTION00312000000000000000">The trouble with storage</A>
</UL>
<LI><A NAME="tex2html71"
  HREF="gitt.html#SECTION00320000000000000000">Day 3 - ``A possible solution''</A>
<UL>
<LI><A NAME="tex2html72"
  HREF="gitt.html#SECTION00321000000000000000">Version Control Nuances</A>
<LI><A NAME="tex2html73"
  HREF="gitt.html#SECTION00322000000000000000">Distributed Version Control</A>
<LI><A NAME="tex2html74"
  HREF="gitt.html#SECTION00323000000000000000">Branching</A>
<LI><A NAME="tex2html75"
  HREF="gitt.html#SECTION00324000000000000000">Staging</A>
<LI><A NAME="tex2html76"
  HREF="gitt.html#SECTION00325000000000000000">Workflow</A>
<LI><A NAME="tex2html77"
  HREF="gitt.html#SECTION00326000000000000000">Offline Committing</A>
<LI><A NAME="tex2html78"
  HREF="gitt.html#SECTION00327000000000000000">Developer Interaction</A>
</UL>
<LI><A NAME="tex2html79"
  HREF="gitt.html#SECTION00330000000000000000">Day 4 - ``A decision is reached''</A>
<UL>
<LI><A NAME="tex2html80"
  HREF="gitt.html#SECTION00331000000000000000">Analysing Your Requirements</A>
</UL>
<LI><A NAME="tex2html81"
  HREF="gitt.html#SECTION00340000000000000000">Day 5 - ``Working like a team''</A>
<UL>
<LI><A NAME="tex2html82"
  HREF="gitt.html#SECTION00341000000000000000">Team Organisation</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html83"
  HREF="gitt.html#SECTION00400000000000000000">Week 2</A>
<UL>
<LI><A NAME="tex2html84"
  HREF="gitt.html#SECTION00410000000000000000">Day 1 - ``We are coders, we use Git!''</A>
<UL>
<LI><A NAME="tex2html85"
  HREF="gitt.html#SECTION00411000000000000000">Setting Up the Environment</A>
<LI><A NAME="tex2html86"
  HREF="gitt.html#SECTION00412000000000000000">Initialising A Repository</A>
</UL>
<LI><A NAME="tex2html87"
  HREF="gitt.html#SECTION00420000000000000000">Day 2 - ``Making commitments''</A>
<UL>
<LI><A NAME="tex2html88"
  HREF="gitt.html#SECTION00421000000000000000">Let's Make a Repository</A>
<LI><A NAME="tex2html89"
  HREF="gitt.html#SECTION00422000000000000000">Committing the Uncommitted</A>
<LI><A NAME="tex2html90"
  HREF="gitt.html#SECTION00423000000000000000">How do we change the commit message editor?</A>
</UL>
<LI><A NAME="tex2html91"
  HREF="gitt.html#SECTION00430000000000000000">Day 4 - ``Let's do this right, not fast''</A>
<UL>
<LI><A NAME="tex2html92"
  HREF="gitt.html#SECTION00431000000000000000">Uh-Oh I Think I Made A Mistake</A>
</UL>
<LI><A NAME="tex2html93"
  HREF="gitt.html#SECTION00440000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html94"
  HREF="gitt.html#SECTION00441000000000000000">Commands</A>
<LI><A NAME="tex2html95"
  HREF="gitt.html#SECTION00442000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html96"
  HREF="gitt.html#SECTION00500000000000000000">Week 3</A>
<UL>
<LI><A NAME="tex2html97"
  HREF="gitt.html#SECTION00510000000000000000">Day 1 - ``But how do I see what's going on?''</A>
<UL>
<LI><A NAME="tex2html98"
  HREF="gitt.html#SECTION00511000000000000000">Logging in Git</A>
</UL>
<LI><A NAME="tex2html99"
  HREF="gitt.html#SECTION00520000000000000000">Day 2 - ``But I need more information''</A>
<UL>
<LI><A NAME="tex2html100"
  HREF="gitt.html#SECTION00521000000000000000">Digging a little deeper</A>
</UL>
<LI><A NAME="tex2html101"
  HREF="gitt.html#SECTION00530000000000000000">Day 3 - ``So what actually changed?''</A>
<UL>
<LI><A NAME="tex2html102"
  HREF="gitt.html#SECTION00531000000000000000">Doing the diff dance</A>
</UL>
<LI><A NAME="tex2html103"
  HREF="gitt.html#SECTION00540000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html104"
  HREF="gitt.html#SECTION00541000000000000000">Commands</A>
<LI><A NAME="tex2html105"
  HREF="gitt.html#SECTION00542000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html106"
  HREF="gitt.html#SECTION00600000000000000000">Week 4</A>
<UL>
<LI><A NAME="tex2html107"
  HREF="gitt.html#SECTION00610000000000000000">Day 1 - ``Finally we're getting somehere''</A>
<UL>
<LI><A NAME="tex2html108"
  HREF="gitt.html#SECTION00611000000000000000">Planting trees</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html109"
  HREF="gitt.html#SECTION00700000000000000000">Acknowledgements</A>
<UL>
<LI><A NAME="tex2html110"
  HREF="gitt.html#SECTION00710000000000000000">``A Huge Thank You''</A>
<UL>
<LI><A NAME="tex2html111"
  HREF="gitt.html#SECTION00711000000000000000">L<SUP>A</SUP>TEX Support</A>
<LI><A NAME="tex2html112"
  HREF="gitt.html#SECTION00712000000000000000">Git Support</A>
</UL></UL></UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00200000000000000000">
Introduction</A>
</H1>

<H1><A NAME="SECTION00210000000000000000">
How this book works</A>
</H1>

<P>
Welcome to Git In The Trenches or GITT, a book designed to help you both apply and understand the subtleties of Git, perhaps the most powerful version control system in use today.  This book isn't supposed to be purely a technical reference, moreover it is hoped that the experiences and scenarios that you encounter will help give ways to apply Git in practical applications.  Git is a hugely powerful system and once harnessed you are most likely going to wonder how you managed without it.

<P>
GITT follows the lives of some developers at a fictional company called Tamagoyaki Inc.  They are a small software outfit who write bespoke software for people.  It may be that you work for a company that is very similar to Tamagoyaki Inc and you are looking to implement a version control system for your own company, or it could be that you have been using a version control for a long time.  Regardless of which box you fit into, GITT should provide you with some useful knowledge in a way that is designed to help you remember the scenarios and their associated solutions.

<P>
The book will follow the lead developer John, as he struggles to bring the company into line by implementing a version control system.  It's not something he's ever really used in earnest and he feels a little out of his depth.  It is hoped that your confidence and knowledge about both version control systems, and Git in particular, will grow whilst reading GITT.  

<P>
The chapters are presented as weeks during the implementation of Tamagoyaki Inc's VCS.  Each chapter spells a new week in the project and you will follow the life of John and his colleagues as they solve problems and learn tricks of the Git trade.  As well as presenting and solving common issues, the book will also be littered with breakout boxes, intended to tell you exactly what is happening inside Git at each stage.  This is intended to further your knowledge and understanding of this powerful piece of software.  At the end of each chapter are "John's Notes" which should build into a quick reference guide, also included with the book.

<P>
Often knowing the commands is not the only piece of the puzzle.  A good understanding of the underlying system, how it reacts when you press that all important «Enter» button, is essential if you want to be able to hold your cool in a crisis.  So let's start at Week 1 and find out why Tamagoyaki Inc even need a version control system.

<H1><A NAME="SECTION00300000000000000000">
Week 1</A>
</H1>

<H1><A NAME="SECTION00310000000000000000">
Day 1 - “Things need to change”</A>
</H1>

<H2><A NAME="SECTION00311000000000000000">
Meeting the Team</A>
</H2>

<P>
If you're already a seasoned version control user, you may want to skip this chapter.  It's kind of like an introduction to why we even need version control systems in the first place.  This chapter looks at Tamagoyaki Inc's requirements and why they choose the VCS that seemed right for them.  It also deals with the events that led up to the defining "We need a VCS!" discussion.

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>
John sat at his desk and looked out of the window.  The rain was drizzling down the pane, but he didn't care.  It was a quiet Monday morning, the release had gone well on Friday and John was just thinking about implementing the new abstraction layer to the database he'd been asked for.  Through the music playing in his headphones he hardly noticed his boss, the chief designer and the CEO approaching his desk.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“John,” shouted his boss, Markus, “get your team into the board room.  Now!”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Things didn't look good. 
</BLOCKQUOTE>
<P><BLOCKQUOTE>
<DIV ALIGN="CENTER">
* * * 

</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, what we'd like to know John, is just how a bug that was supposed to have been....” the CEO back-tracked, “that was demonstrated as being fixed two weeks ago, made it into the final release of the software?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I'm sorry,” John started, before being cut off.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Sorry doesn't cut it John,” said the CEO, “This is a major embarrassment for Tamagoyaki Inc.  We need to ensure this doesn't happen again.”  He turned to Markus.  “I want a report on my desk by the end of the day that states what the problem was, how it slipped through our fingers and what safe guards we are going to put into place so that things like this never happen again.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Of course sir,” Markus replied.  He was bright red with his own variety of embarrassment.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The room fell silent and a few minutes of silence passed before the meeting was drawn to a close and John and his team were allowed to leave.
</BLOCKQUOTE>
<P><BLOCKQUOTE>
<DIV ALIGN="CENTER">
* * * 

</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, you're telling me that when Simon came back from holiday, he picked up an older copy of the library from the network share and pushed his latest code into that?”  Markus was holding back the anger.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“It appears that way.”  Said John sullenly.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Oh for crying out loud.  How did this happen?  Why wasn't he using the latest version?  And why didn't QA pick up on it?”  Markus looked across the meeting room at John.  “John, you need to make sure this doesn't happen again.  Find a solution!”
</BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00312000000000000000">
The trouble with storage</A>
</H2>

<P>
It's not like this situation is completely uncommon.  At one point or another most people have managed to pull old code from somewhere and mistakenly use it in place of the latest, up to date, version.  When storing code on network shares or on local disks, it's easy to lose sight of which version is which, no matter how good your naming convention is.  It's like trying to build one of the baked bean puzzles when you have three boxes of them and you tipped all the pieces into one box for simplicities sake.  Not so simple any more is it?

<P>
People have a tendency to use folder names which mean something to them.  However it doesn't necessarily follow that this name means something to another developer.  “Version 2.3 - fixed bug a” only means something to you if you know what bug a is and something like “Version 2.3 - fixed bug a(2)” is even worse.  Unfortunately allowing people to free form type their own descriptive file names will always lead to problems like this.  When these files are stored on a network share, the problem is exacerbated ten fold because there is often no fixed reference point.

<P>
So what's the solution?  Well, in a large number of cases version control can make sure that not only is there a defined place for data to sit, and with a defined structure, but also that you have a full history of the code.  Accountability is very important in code development, especially when releasing software to customers.  In some situations a customer will even mandate that the code being developed for them is stored in a version controlled environment.  In this way, the customer can ask when a certain piece of code was edited, or when an addition first entered the code base.

<P>

<H1><A NAME="SECTION00320000000000000000">
Day 3 - “A possible solution”</A>
</H1>

<H2><A NAME="SECTION00321000000000000000">
Version Control Nuances</A>
</H2>

<P>
There are many offerings for version control out there, Git, Mercurial, Subversion, CVS, and Bazaar to name but a few of the open source ones.  Perhaps a more pertinent question is just which version control system to use.  Each of the has their relative advantages and disadvantages, but some will be suited to certain tasks more that others.  Also, it's worth noting that if you are interacting with other pieces of software, or share some development with another set of developers, it is a good idea to enquire to see what they are using.  Usually you'll find collaboration, forking and patching a lot easier if you're using the same version control system as your upstream or partners.

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“So really it seems like the only real solution to this problem bar Klaus' suggestions of reducing the workforce to only one developer, thank you Klaus,” Klaus nodded in acknowledgement back to John, “is to implement a version control system.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Markus chewed his lip.  “I can see where you're coming from here John, but aren't version control systems really expensive?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“There are a number of open source offerings we could take a look at first,” piped up a new voice in the discussion, “some of them are supposed to be pretty good.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Let's all go away, take a look at the various pros and cons and reconvene tomorrow to discuss the findings,” said John.  “Sound fair?”
</BLOCKQUOTE>
<P>
So now we need to take a look at some various features of version control systems and see what the various advantages and disadvantages are of each.  We are going to focus on Git here primarily, as this is what the rest of the book is all about.  It is assumed that if you are reading this book, you have most likely already made the decision about which version control system you are going to use.  So let's talk about the various features that are prevalent in most version control systems.

<P>

<H2><A NAME="SECTION00322000000000000000">
Distributed Version Control</A>
</H2>

<P>
Version control systems usually fit into one of two categories; centralised, or distributed.  Git is a distributed version control system.  It has been designed to run almost everything at a local level.  This will become much more clear when we talk about other features of Git a little later on, but for now just understand that Git isn't tied to a centralised repository.  This is super powerful.  No Really!

<P>

<H2><A NAME="SECTION00323000000000000000">
Branching</A>
</H2>

<P>
Most version control systems offer branching as part of their default features set.  Branching allows developers to create in essence a clone of their repository and mess around with it, safe in the knowledge that they can switch back to the original whenever they need to.  This allows developers the freedom to experiment with all manner of things without being afraid of affecting the original/clean code base.

<P>
Git implements branching in a special way.  Most other version control systems implement branching in a way that almost creates a separate repository.  This is slow and cumbersome.  Git's branching method gives developers the ability to create multiple local branches to play with.  Due to it's distributed nature, when pushing code to a more central location for others to pull from, developers can choose which branches they want to push, allowing code to be experimented with privately.

<P>
The implementation of branching in Git is fast.  Due to the fact that repositories are stored locally, the speed of creating a local branch is limited only by the speed of the disks on a local machine.

<P>

<H2><A NAME="SECTION00324000000000000000">
Staging</A>
</H2>

<P>
Git deals with commits differently to most other version control systems by introducing the staging area.  The staging area allows developers to prepare their commits before they are written to the repository.  Why is this useful or any different to any other version control system.  In Git you can make a change to a file, add it to the staging area, and then continue to make changes to that file, even though you have not yet actually committed anything.
It should be noted that it's not absolutely necessary to use the staging area, but it is there for developers wishing to utilise it.

<P>

<H2><A NAME="SECTION00325000000000000000">
Workflow</A>
</H2>

<P>
Due to the way that Git has been designed, it's possible to use it in practically any work flow you can think of.  Three of the most common workflows are explained below, and Git can work in any of these, making it one of the more versatile systems out there.

<P>

<H3><A NAME="SECTION00325100000000000000">
Centralised Workflow</A>
</H3>

<P>
In a centralised workflow, a single shared repository is used.  Multiple developers pull changes from here into local working copies, work on the local version, and then push it back up to the central location.  

<P>
Git handles this workflow just like most other version control systems.  A developer can not push his changes until he has pulled everything up to the latest from the central repository and resolved any conflicts that may arise.

<P>
Using the centralised model for the workflow, each developer has the same level of access to the repository and is considered as <SPAN  CLASS="textbf">important</SPAN> as each other.  For smaller teams, this method will work well, but as teams get larger, a centralised method may get tedious.

<P>

<DIV ALIGN="CENTER"><A NAME="117"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .1:</STRONG>
Centralised Workflow</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>	</TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00325200000000000000">
Integration Manager Workflow</A>
</H3>
The integration manager workflow is similar to the centralised workflow because there is still a <SPAN  CLASS="textbf">blessed</SPAN> repository which everyone uses as a reference.  The difference here is that there is only one person who has the rights to push changes to the <SPAN  CLASS="textbf">blessed</SPAN> repository.  This person is referred to as the Integration Manager.  

<P>

<H3><A NAME="SECTION00325300000000000000">
Blessed</A>
</H3>
A blessed repository is one which has the approval of the managers of the project.  The blessed repository is supposed to be the de facto standard where all other clones are made from.  If there is one place where code should be correct, it is the blessed repository.  If you are hosting the project in a public place, the blessed repository will usually be the one that is made available to people as a stable point for developing from.

<P>
This workflow is handled exceedingly well by Git.  Developers will work on their repositories locally and then once they are happy, will push their changes to a location where the Integration Manager can see them.  The Integration Manager will then review the changes that the developers have made and will merge them into their own local repository.  Once they are happy that everything is working well, the Integration Manager will push their changes to the blessed repository so that all the other developers can access the changes.

<P>

<DIV ALIGN="CENTER"><A NAME="127"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .2:</STRONG>
Integration Manager Workflow</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>	</TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00325400000000000000">
Dictator and Lieutenant Workflow</A>
</H3>

<P>
The dictator and lieutenant workflow is practically an extension to the integration manager workflow.  It is more suited to larger teams, where modules or sections of the code can be assigned to a <SPAN  CLASS="textbf">Lieutenant</SPAN> who is responsible for blessing all of the changes to that particular section.

<P>
Once the Lieutenants are happy with their code, they make it available to the Dictator.  The Dictator then takes on a role similar to the Integration Manager from the previous model.  In the end, all of the changes are pushed to the blessed repository for the developers at the bottom of the tree to pull from.

<P>

<DIV ALIGN="CENTER"><A NAME="133"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .3:</STRONG>
Dictator and Lieutenant Workflow</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>	</TD></TR>
</TABLE>
</DIV>

<P>
The main thing to remember, is that Git can utilise any of these workflows.  This makes it a very flexible system, allowing you to work in whichever way you decide.

<P>

<H2><A NAME="SECTION00326000000000000000">
Offline Committing</A>
</H2>

<P>
Perhaps one of the most useful and undervalued features of version control systems is that of offline committing.  It may be undervalued because not all version control systems have it.  Offline committing is the ability to continue adding and committing files to the repository without being connected to a centralised repository.  

<P>
When travelling or just simply when out of the office, developers and integrators alike are able to continue managing code, viewing histories, viewing diffs and committing changes to their repository.  This is all due to the fact that Git does 99% of all of it's operations locally.  When a repository is cloned, Git actually sets up a copy of the entire repository locally, giving developers the flexibility to work anywhere, without requiring access to the company network.

<P>
When returning to the office, the developers simply push their changes to their âpublicâ space, be it local or to a blessed location, and all of the commits that have been made whilst they are away are then made available to the rest of the team, including all history and snapshots.

<P>

<H2><A NAME="SECTION00327000000000000000">
Developer Interaction</A>
</H2>

<P>
One factor to consider when choosing a version control system, is that of developer interaction.  By this we are referring to the way in which developers use and interact with the version control system itself.  There are four main methods for VCS interaction

<P>

<H3><A NAME="SECTION00327100000000000000">
Graphical User Interface Client (GUI)</A>
</H3>

<P>
A graphical user interface allows the developer, or user, to physically manipulate the repository using a mouse pointer and a graphically rich environment.  A GUI client will typically consist of separate application which is run when a user wants to make changes to a repository such as adding files or commuting changes.  

<P>
Some developers prefer having a separate client with which to interact with their repository, whilst others prefer to have things integrated a little more.

<P>

<H3><A NAME="SECTION00327200000000000000">
Shell Extension Integration</A>
</H3>

<P>
Shell integration allows the user to interact with their repository using the graphical environment that they would usually use for manipulating files and performing routine directory maintenance.  One of the most common Shell Extensions for Git is the TortoiseGit interface which integrates itself into Windows Explorer, allowing a user to right click on an entity whilst inside a git working tree, and be presented with a context sensitive menu for VCS operations.

<P>

<H3><A NAME="SECTION00327300000000000000">
Command Line Interface (CLI)</A>
</H3>

<P>
The command line interface is favour by many developers as they can script with it and can see exactly what is going on, often in much more detail that with a GUI.  The CLI gives total control over the product and it is worth noting that almost all version control systems start life as command line driven interfaces.  Why is this so?  It can take a lot of time and effort to put all the options and nuances of a system into a GUI.  The CLI will almost always be the most powerful of all tools, especially where version control systems are concerned.

<P>

<H1><A NAME="SECTION00330000000000000000">
Day 4 - “A decision is reached”</A>
</H1>

<P>

<H2><A NAME="SECTION00331000000000000000">
Analysing Your Requirements</A>
</H2>

<P>
The most important aspect of choosing a version control system, is to define your requirements.  These can be few, or they can be quite specific, let's see what John and his team decide are the most important aspects for them and ultimately what they decide upon.

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“Offline commuting seems like it's a pretty useful thing to have.”  Mike said nodding.  “Especially with people like John travelling all the time.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I have to admit, it would be nice to be on the plane, and be able to pull all the code together, knowing all of the history of each section,” replied John.  “The branching in Git seems to be quite powerful as well.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I must admit,” chimed in Klaus, “I've used branching a bit in Subversion before and it was a lifesaver.  It's supposed to be super fast in Git too.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“And owing to the fact that Git seems to support several workflows, it means we can try them out and see how they work for us.”  Markus looked at the team.  “Are we settled on Git then?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The team nodded and everyone walked out of the board room except John.  Things were about to get interesting for him.  Very interesting.
</BLOCKQUOTE>
<P>
Since this book is all about Git, we won't delve too far into the workings or features of other version control systems.  Hopefully, this chapter has given you enough information to go and check out some of the other systems, if you feel the need to.  The main thing to bear in mind is that Git is a Distributed Version Control system.  While this is so, it is equally important to remember that it can be used in the same workflow models as Centralised Version Control systems.

<P>
John and his teams requirements are nothing special.  They are a smallish team looking to reap the benefits of having their code in a well organised system.  They are also looking to reorder their team functions and dynamics in order to fit around the version control system and really make it core to their development.  

<P>
Version control is not a replacement for workflow.  It is not intended to make everything better.  If you have people going off and doing their own thing and being careless about the way they work, version control is not going to suddenly fix everything.  A tool is just that, a tool and version control is no different.  You can buy the messiest builder in the trade a nice shiny new tool box, but unless they have the mindset to want to change, you'll probably find that all the tools end up in the largest compartment at the bottom.

<P>

<H1><A NAME="SECTION00340000000000000000">
Day 5 - “Working like a team”</A>
</H1>

<P>

<H2><A NAME="SECTION00341000000000000000">
Team Organisation</A>
</H2>

<P>
Now that we have the basics dealt with, let's take a little look at how John arranges his team, and see whether version control is going to work for them.  It is important that the team understands how the model should work, what they are expected to do and what level of access they have.  Most of the time people will get more frustrated about not know what they should or shouldn't be doing, rather than that they do or don't have access to certain things.

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>
It was 4:36pm on the Friday and the table in the board room was littered with empty coke cans, pizza boxes and one Japanese bento lunchbox, owned by a particularly stubborn member of the team who had vowed never to eat pizza gain.  It had been Marcus' idea to bring in the food reinforcement to help the discussions along.  The team were trying to decide how to organise their model.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“There's nothing to say we can't use a combination of the models is there?” asked Mike.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I suppose not,” said John.  “What did you have in mind.”  His glasses were slipping down his forehead now and he was getting pretty tired.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well, I figure, we basically have the software split into two parts.  We have the library, which myself, Klaus and Jack work on.  Then there's the UI elements which Simon, Martha and Rob handle..  I know there are the tools which Eugene works on too.”  Everyone had started to listen to Mike as he continued.  “John, you don't want to have to deal with the library component as this more Klaus' space.  So why don't we have two dictators.  Klaus and yourself have access to push up to the blessed repository.  John can pull from his guys, Klaus from his and we end up with an good model for version control.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John raised his eyebrows, “Not bad Mike,” he said, genuinely impressed.  After spending a few hours going through the various models and who was  in charge of what, it felt good to have finally reached a decision.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, we start on Monday then?” asked Markus, who had been listening from the other end of the table.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Indeed.”  Announced Klaus, “Monday we all become Gits!”
</BLOCKQUOTE>
<H1><A NAME="SECTION00400000000000000000">
Week 2</A>
</H1>

<H1><A NAME="SECTION00410000000000000000">
Day 1 - “We are coders, we use Git!”</A>
</H1>

<H2><A NAME="SECTION00411000000000000000">
Setting Up the Environment</A>
</H2>

<P>
So now we are ready to being delving into and actually using Git, right?  Well, not exactly.  First we have to decide upon how the workflow model we have envisaged is implemented in out version control system.  With Git being so versatile, it's both a blessing and a danger.  It is a good idea to define from early on, exactly how you would like the developers, lieutenants and dictators to behave, before you begin actually committing any code.  Sometimes this isn't possible.  It's quite feasible that you have never used a version control system like Git before and you begin by muddling your way through.  This is normal, but if you are in charge of implementing this type of system for a professional environment, you should really consider first how this is going to work. 

<P>
Conceptually, the model which was discussed previously is easy to imagine.  We have two dictators, who both have access to the blessed repository and then several developers, who are going to have their changes reviewed and included, by the aforementioned dictators.  The physical representation of the workflow model is summarised in the diagram below.

<P>

<DIV ALIGN="CENTER"><A NAME="347"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .1:</STRONG>
Tamagoyaki Inc's Physical Structure</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
The physical structure is all well and good, but it doesn't determine exactly how the data is moved, just who is responsible for it at each stage in the process.  What is required, is a detailed analysis of where the data flows from and to.  A data flow diagram is useful, but not essential.  However, we will create a slightly different form of diagram to show how the data will be moved from one person to another.  Before we go ahead and look at the diagram, let's go back to the trenches to see how the guys are coping with their repository design. 

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“John, why are we all sat in here at 9:45am on Monday morning.”  Klaus whined.  “I haven't even ingested enough coffee to check emails yet, let alone meet with people.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John grinned, “I don't think any amount of coffee will help you there Klaus, it's you winning personality that will pull you through.”  The rest of the team laughed and then subsided as John started drawing furiously on the board.  “So we have our physical model.  We know which people are going to be in charge of things, but we don't know yet how to arrange our repositories.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Good point,” chimed Mike. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So.  Obviously we're going to have a blessed repository,” said John, drawing a circle on the board.  He stepped back, one hand on chin.  “Then I would imagine Klaus and I will have clones of that repository on our local machines.  We will then modify those and push our changes back up to the central copy.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I thought Git didn't have a central copy?” asked Martha.  There were other moans and grunts. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well,” said John, “as far as I understand it, it doesn't.  I mean Klaus and I will have local copies of the repository too.  We will work on those and then sync our changes back to the server.  It's a sync, moreover a copy.  I think it's actually called a clone.”  He nodded to himself, “And, since Klaus and I will hardly ever overlap on code, we shouldn't ever need to merge or deal with an conflicts.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“But what about us monkeys?” asked Martha, “Where do we get our clones from?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“From the central server of course,” Rob stated smiling. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Yes,” John said, “but I think what Martha is trying to say, is how will you get your updates?”  He started to walk around the room, and one or two of the developers followed him as he reached the windows and leant on the sill.  “I guess you would merge your branch with the blessed one.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The room went silent and the only noise that could be heard was the rattling of the air conditioner in the ceiling above. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Simon spoke out, “Well, I was reading over the weekend about this thing called rebase and how in some cases a rebase is better than merging.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“What's rebase and how is it different to merging?” asked Mike. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well, rebasing is pretty darn clever.  Think of it this way.  You have an upstream branch, in this case, our blessed repository.  You are happily making changes.  When the upstream changes, you could merge the changes in from blessed.  If you do this, you create a single commit which merges the changes in.  It works, but...” he trailed off a little, “it can cause problems in certain instances.  A better way to handle it is with rebasing.  Rebasing can take all the changes you have made, squirrel them away, pull down all the changes to bring it up to date, and then whack your changes on top.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John breathed out, “It sounds pretty cool Simon, but one things is abundantly clear, we need to learn more about the Git basics before we start delving into this merging and rebasing.  Let's spend the rest of the day playing with some test repositories and reconvene tomorrow.”
</BLOCKQUOTE>
<P>
If you've never played with a version control system before it is a good idea to take some time to just play.  Pretty soon you'll have learned the basics and will be in a position where you will want to put your newly honed skills into practice.  Though playing on test repositories is good, it is quite usual that you need to actually use the system in a real environment before real problems arise.  The rest of this chapter is a very quick introduction to Git.  It is presented as an introduction, because it is hoped and expected that the you will take some time out to get to know the system and how it works. 

<P>

<H2><A NAME="SECTION00412000000000000000">
Initialising A Repository</A>
</H2>
The first thing we need to do is to understand two very important things: 

<P>

<OL>
<LI>How to create a Git repository 
</LI>
<LI>What a Git repository actually is 
</LI>
</OL>

<P>
The first of these is relatively easy to perform.  

<P>
<PRE>[frame=single,fontsize=\relsize{-3}]
john@akira:~$ mkdir coderepo 
john@akira:~$ cd coderepo 
john@akira:~/coderepo$ git init 
Initialized empty Git repository in /home/john/coderepo/.git/ 
john@akira:~/coderepo$ git
</PRE> 

<P>
What we've done here is create a new directory called coderepo, moved into it, and then run the git init command.  The result of this command is a new directory in the coderepo dir called .git.  This directory will hold a local copy of our entire repository.  This will allow us to create branches, merge changes, rebase things and ultimately push our changes to somewhere else.

<P>

<H3><A NAME="SECTION00412100000000000000">
What's inside the Git repository?</A>
</H3>

<P>
Let's take a brief look into the directory structure, to see what this command has created in the <TT>.git</TT> folder.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo/.git$ ls -la 
total 40 
drwxr-xr-x 7 john john 4096 2011-02-17 19:23 . 
drwxr-xr-x 3 john john 4096 2011-02-17 19:23 .. 
drwxr-xr-x 2 john john 4096 2011-02-17 19:23 branches 
-rw-r--r-- 1 john john   92 2011-02-17 19:23 config 
-rw-r--r-- 1 john john   73 2011-02-17 19:23 description 
-rw-r--r-- 1 john john   23 2011-02-17 19:23 HEAD 
drwxr-xr-x 2 john john 4096 2011-02-17 19:23 hooks 
drwxr-xr-x 2 john john 4096 2011-02-17 19:23 info 
drwxr-xr-x 4 john john 4096 2011-02-17 19:23 objects 
drwxr-xr-x 4 john john 4096 2011-02-17 19:23 refs 
john@akira:~/coderepo/.git$
</PRE> 

<P>
<SPAN  CLASS="textbf">branches</SPAN> - Though depreciated now, this folder stores shorthands for git pull, push and fetch commands, by creating a file, the name of which is passed to the command instead of the repository argument.

<P>
<SPAN  CLASS="textbf">config</SPAN> - This is the main config file for Git.  It is the first place git looks for upon invocation.  If this file is not present, Git will inspect&nbsp;/.gitconfig.  After this, Git will go to /etc/gitconfig.  The file holds information about the remotes, tracking branches, push configurations and many more items.

<P>
<SPAN  CLASS="textbf">description</SPAN> - This is a simple text file which gives a description to a repository when being view via gitweb or similar.

<P>
<SPAN  CLASS="textbf">HEAD</SPAN> - This file is a pointer to the parent commit of your current branch.

<P>
<SPAN  CLASS="textbf">hooks</SPAN> - Scripts can be placed in here to perform operations at certain points during the commit process.

<P>
<SPAN  CLASS="textbf">info</SPAN> - The info folder contains some additional information about the repository

<P>
<SPAN  CLASS="textbf">objects</SPAN> - The is the directory that holds all of the actual files that are stored in the repository.  The files are named by their SHA-1 values.  Inside the folder are a number of directories which make up the first 2 characters of the SHA-1 value.  The remaining portion of the SHA-1 hash is used to name the file.

<P>
<SPAN  CLASS="textbf">refs</SPAN> - This folder holds the files that files for local branches, remote branches and tags.

<P>
More files and folders may appear here during the running of the repository.

<P>
Something that is crucial to the running of a repository, whether you are an administrator of Git, or a developer who is using it, is an understanding of how Git works.  It is fine to jump in and play with the repository and test the water, but before committing to using Git in a production environment, you should understand what Git actually does in the background in some detail. 

<P>
During the writing of this book several people have told me that Git is one of the only version control systems where a good understanding of how the underlying system works is not just highly recommended, but bordering on essential. 

<P>
Let us take a few minutes to talk about how Git works internally and how the data is actually stored.  Git doesn't store changes to files, but actual snapshots of files at specific points in time.  It refers to these by running an SHA-1 hash against the file.  In this way, it is easy to Git to detect if a file has changed.  If the SHA-1 hash of a file changes, then the file must have been modified. 

<P>
When a commit is made to the repository, Git stores a few things.  A commit object is created.  This contains information about who made the commit, the parent of the commit and points to a tree object.  The tree object describes what the repository looked like at the time of the commit.  In other words the tree object, tells Git what files were in there.  Lastly, Git stores the files that were in the repository under their SHA-1 names in the objects directory.  Of course Git is super clever here because if you have exactly the same file in multiple commits, the SHA-1 hash of that file doesn't change and therefore Git only stores one copy of the file to save space.

<P>
The commit object is also referred to by an SHA-1 hash.  This is different to many other version control systems which use either a number that refers to the repository or a per file version number.  Getting used to seeing 40 character SHA-1 hashes can take a little time.  Saying "I need the commit referred to as  bf81617d6417d9380e06785f8ed23b247bea8f6d," is certainly not as easy as saying you need revision 6.  However, Git handles these hashes well, and you can reference a commit using a few of the characters from the beginning, as long as those characters uniquely refer to that commit, ie, as long as your choice isn't in any way ambiguous.

<P>

<H1><A NAME="SECTION00420000000000000000">
Day 2 - “Making commitments”</A>
</H1>

<H2><A NAME="SECTION00421000000000000000">
Let's Make a Repository</A>
</H2>

<P>
The most simple way of committing a file into the repository is to create it, or bring it into your working copy and use the commands below.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/touch my_first_committed_file
john@akira:~/coderepo$ touch my_first_committed_file
john@akira:~/coderepo$ git add my_first_committed_file
john@akira:~/coderepo$ git commit -m 'My First Ever Commit'
[master (root-commit) 8820692] My First Ever Commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 my_first_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
What we have done here, is to create a new blank file and add it into the repository using Git's add command.  Then we have committed it into the repository.  Let's make a few changes to our working copy and see what the result is.  First we are going to add another two new files, then we are going to make changes to our original file and finally we are going to run git status to see what Git has to say about our changes.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ echo "Change1" &gt; my_first_committed_file 
john@akira:~/coderepo$ touch my_second_committed_file
john@akira:~/coderepo$ touch my_third_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in 
working directory)
#
#	modified:   my_first_committed_file
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_second_committed_file
#	my_third_committed_file
no changes added to commit (use "git add" and/or "git commit 
-a")
john@akira:~/coderepo$
</PRE> 

<P>
So we can see that Git is reporting that there are changes to our first committed file, and that our second and third files are <SPAN  CLASS="textbf">untracked</SPAN>.  Untracked files are ones which Git detects as being present in the working directory, but which haven't yet been added and there for upon running a commit, these files will not be added to the repository.  Notice that if we tried to run a commit now, nothing would actually be committed to the repository.  Even though there are changes to to my_first_committed_file, we have not asked Git to include these.  So, let's go ahead and do that, and at the same time we'll make a few changes to my_second_committed_file, and add those too.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git add my_first_committed_file
john@akira:~/coderepo$ echo "Change1" &gt; my_second_committed_file 
john@akira:~/coderepo$ git add my_second_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	modified:   my_first_committed_file
#	new file:   my_second_committed_file
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
Now we can see that one of the sections has changed to "Changes to be committed".  So this means that Git has recognised and remembered that we are expecting these files to be committed when we next run a git commit.  

<P>

<H2><A NAME="SECTION00422000000000000000">
Committing the Uncommitted</A>
</H2>

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“John, what is going on here?” shouted Klaus from across the hallway.  The entire office had heard Klaus banging his hands down on the desk for the last fifteen minutes.  “John!” the shout turned into a scream.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Calm down Klaus, I'm just coming.”  John walked over to Klaus and pulled up one of the folding plastic chairs.  After a few minutes of fumbling he finally managed to take up his position next to an infuriated Klaus.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“John, Git is driving me crazy.  I have added files to the repository and I keep running a commit, but the changes aren't getting put into the blasted repo.”  Klaus was clearly distressed and John resisted the urge make jokes.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John pointed at the screen.  “Run a git status Klaus and I'll show you what the problem is.”
</BLOCKQUOTE>
<P>
To understand what Klaus was getting in a spin about, let's make a change to my_second_committed_file now and see how this affects things.  Remember we have already added the file, but we haven't yet made a commit.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ echo "Change2" &gt;&gt; 
my_second_committed_file 
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	modified:   my_first_committed_file
#	new file:   my_second_committed_file
#
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in 
working directory)
#
#	modified:   my_second_committed_file
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
How interesting!  We now have three sections and one of our files appears twice under both Changes to be committed and Changed but up updated.  What does this mean?  If you remember back, we spoke about a staging area.  This is one area in which Git differs to many version control systems.  When you <SPAN  CLASS="textbf">add</SPAN> a file into the repository, Git will actually make a copy of that file and move it into the staging area.  If you then go ahead and change that file, you would need to run another git add in order for Git to copy your changed file into the staging area.  The most important thing to remember is that Git will only ever commit what is in the staging area.

<P>
So, if we go ahead and run our commit now, we will only have the changes marked in Changes to be committed appearing in out repository.  

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git commit -m 'Made a few changes to 
first and second files'
[master e86ddea] Made a few changes to first and second files
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 my_second_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
In our examples, we have used the syntax <TT>git commit -m 'Message'</TT>.  This is a slightly special way of committing, it allows us to specify our commit log message on the command line.  If we wanted to, we could run the command git commit and this would open a text editor that we could use to input out commands.

<P>

<H2><A NAME="SECTION00423000000000000000">
How do we change the commit message editor?</A>
</H2>

<P>
We spoke earlier about the configuration file and how it stores information about our Git instance.  Git can use any text editor you require, even a graphical one, though the need rarely arises.  As mentioned earlier, Git has a preference lever when talking about configuration.  First and foremost it will look in the repositories own 'config' file in the .git folder.  Then, it will look in the users <TT>&nbsp;/.gitconfig</TT> file.  Finally, Git will look in your distributions own global folder.  

<P>
If we wanted to change the editor that Git would use to modify commit messages, we can either modify the files directly, or run a command similar to the following;

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
git config core.editor "nano"
</PRE>

<P>
If we want the changes to apply globally, meaning it would affect all repositories we administrate as this user, unless overridden by a repository setting, we would run the following;

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
git config --global core.editor "nano"
</PRE>

<P>
Let us finish off our round of committing by using the <TT>git commit -a</TT> option.  This commits all of the changes to files which are already tracked.  In this way, we do not have to specify the files with <TT>git add</TT>, like we have had to previously.  Any file which has been modified and has previously been added to the repository, will have it's changes committed upon running that command.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status 
# On branch master 
# Changed but not updated: 
#   (use "git add &lt;file&gt;..." to update what will be committed) 
#   (use "git checkout -- &lt;file&gt;..." to discard changes in 
working directory) 
# 
#	modified:   my_second_committed_file 
# 
# Untracked files: 
#   (use "git add &lt;file&gt;..." to include in what will be 
committed) 
# 
#	my_third_committed_file 
no changes added to commit (use "git add" and/or "git commit 
-a")
</PRE> 

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git commit -a -m 'Finished adding initial 
files' 
[master 6ca160c] Finished adding initial files 
 1 files changed, 1 insertions(+), 0 deletions(-)
</PRE> 

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status 
# On branch master 
# Untracked files: 
#   (use "git add &lt;file&gt;..." to include in what will be 
committed) 
# 
#	my_third_committed_file 
nothing added to commit but untracked files present (use "git 
add" to track) 
john@akira:~/coderepo$
</PRE> 

<P>

<H1><A NAME="SECTION00430000000000000000">
Day 4 - “Let's do this right, not fast”</A>
</H1>

<P>

<H2><A NAME="SECTION00431000000000000000">
Uh-Oh I Think I Made A Mistake</A>
</H2>

<P>
So now we are fairly well aquainted with adding files into the repository and performing commits.  In a short while we will learn about how to view the changes we have made and perform diffs against various objects.  Before we close out the week, we need to go back to the trenches one last time.

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“Rob, ya got a second?” asked Mike.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Sure, what's up?” replied Rob from across the office.  “Gimme two secs to make this commit.”  The office went silent again whilst Rob's fingers darted across the keyboard.  “Ahh.  Damn it!” shouted Rob.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Mike rose from his chair and walked over to Rob.  “What's up?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I just added a file into the staging area, but I don't want it there.”  He shook his head, “Well not yet anyway.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Mike chuckled, “Sorry for interrupting dude.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Nah, it's OK, I just need to know how to pull this file out of the index.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Git reset,” shouted a voice.  The stillness of the office was interrupted by a chair free wheeling across the floor.  The occupant of the chair was Klaus.  He seemed proud that he was finally getting to grips with things.  “You can use git reset to reset a file that's in the index.”  He grabbed at the keyboard, “Here, lemme show you.”
</BLOCKQUOTE>
<P>
The git reset is great at removing things from the index that you don't want to be there.  Of course, it can do a great many other things, but for now, let us concern ourselves with the scenario presented above.  We are working away, and have added a number of files into the index ready for committing, when we discover that we are actually not ready to commit them.  In the following example, we are going to add the file my_third_committed_file and then remove it from the index.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git add my_third_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	new file:   my_third_committed_file
#
john@akira:~/coderepo$
</PRE> 

<P>
Notice how my_third_committed_file is now ready to be committed to repository.  The problem is we need to add something more to it before we do.  Remember that when we run the git add command, we are copying the file from our working copy to the index.  If we decide we no longer want that file in the repository, we can run the following.  

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git reset my_third_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
nothing added to commit but untracked files present (use "git 
add" to track)
john@akira:~/coderepo$
</PRE>

<P>
We have discarded the file which was residing in the index.  This is very important to note.  We are not moving the file from the index back into our working directory, we are literally just deleting the file from the index.  Our working copy remains unaffected.  We could run the git reset command without appending a file.  If we did this, all the files in the index would have been discarded.  

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“So, I think we are all agreed, I'll keep a version of the repository under Git version control.  Until everyone else feels comfortable with some of the more advanced features.”  John looked around the room for any disagreements but there were none.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Agreed John,” said Markus, “I'm pleased with how you guys are progressing, very pleased, but like John said, it's far better for us to take our time and to implement this correctly, than to rush it and to end up with something that we can't administrate and that we don't know how it works.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So next week, I want you all to start playing with diffing and logs and don't forget we have an important release due too.”  John pushed his glasses further up his nose.  “The week after that we'll start looking at branching and by then we may be at the stage where we can implement our model.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Everyone nodded in agreement.
</BLOCKQUOTE>
<P>
We have run through a few basic commands in Git.  If you are familiar with version control systems, then possibly the only real difference you will have noticed is that of the staging area.  It really is powerful, and allows you to organise and prepare your commits, so that they are both meaningful and coherent.

<P>
For Tamagoyaki Inc, their plan to implement version control was far too aggressive.  Most of the members of the team had never even used a version control system.  When deciding to implement version control, it is essential to ensure that you are doing it for the right reasons.  Version control is a tool to help you to keep things in order, but remember tools are nothing without process.  It is process that is key to the order.

<H1><A NAME="SECTION00440000000000000000">
Summary - John's Notes</A>
</H1>

<H2><A NAME="SECTION00441000000000000000">
Commands</A>
</H2>
<TT>git add</TT> - Add files into the index or staging area

<P>
<TT>git commit </TT> - Commit files into the repository, using text editor for commit message

<P>
<TT>git commit -m '&lt;Message&gt;'</TT> - Commit files into the repository, using the command line to supply commit message

<P>
<TT>git commit -a</TT> - Commit all tracked files into the repository that have changed, using text editor for commit message

<P>
<TT>git reset &lt;path&gt;</TT> - Remove file from index or staging area

<P>
<TT>git status</TT> - Show the status of tracked, changed, untracked files

<H2><A NAME="SECTION00442000000000000000">
Terminology</A>
</H2>
<SPAN  CLASS="textbf">Branch</SPAN> - A way of working on the same set of code in parallel without modifications overlapping

<P>
<SPAN  CLASS="textbf">Commit</SPAN> - A group of objects and a tree in a Git repository

<H1><A NAME="SECTION00500000000000000000">
Week 3</A>
</H1>

<H1><A NAME="SECTION00510000000000000000">
Day 1 - “But how do I see what's going on?”</A>
</H1>

<H2><A NAME="SECTION00511000000000000000">
Logging in Git</A>
</H2>

<P>
Perhaps the best feature of a version control system is the level of accountability that it offers if set up correctly.  What do we mean by this?  People often mistake the word <SPAN  CLASS="textbf">accountability</SPAN> for the word <SPAN  CLASS="textbf">blame</SPAN>.  This is not true at all.  Accountability is key in understanding the events that led up to a particular bug being introduced, or a situation occuring.  How this is dealt with, is a up to the management teams, but accountability should not be something that is revered, it should be something that is looked upon as a tool to help define the cause of a problem.

<P>
By its very nature, a version control system is also a logging system.  Every time we committed something into the repository in the last chapter, we supplied a log message.  In fact, if we don't supply a commit message, let us see what happens.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
nothing added to commit but untracked files present (use "git 
add" to track)
john@akira:~/coderepo$ git add my_third_committed_file
john@akira:~/coderepo$ git commit -a -m ''
Aborting commit due to empty commit message.
john@akira:~/coderepo$
</PRE>

<P>
So, Git will actually not allow you to commit with a blank message.  This is actually fantastic news, as people are far less likely to write a useless message than they are a blank one.  It is very important that when using a version control system you write in a useful commit message.  If you fixed a bug, say so.  If you added a new function, why not put that in too.  When someone wants to find out what a certain commit was for, or even when you come back to the project six months later and realise you've forgotten everything, log messages are crucial in piecing back together a history of development.

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“So John, I've been committing and all that,” started Rob, “but how do I see the history of what I have done.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“It's really pretty simple,” replied John, “But it really depends on what you want to know.”
Rob placed his thumb and forefinger onto his chin.  “Well, for now, I just want to see a list of all of my commits.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“That one's the simplest of all.”
</BLOCKQUOTE>
<P>
At its simplest, <TT>git log</TT> will give an output of all of the commits that have been applied to the current branch.  Depending on what type of machine you are using it on, the output from <TT>git log</TT> will be navigatable, usually using the up and down arrows, with 'q' used to quit.  Let's have a quick look at the output of our test repository and see what the log messages look like.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}]
john@akira:~/coderepo$ git log
commit 6ca160c7226731bf80973fc5bc81f6b9beda7795
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:59:32 2011 +0000

    Finished adding initial files

commit e86ddea25341a75275d316d8ca545aa7c73e97b3
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:06:57 2011 +0000

    Made a few changes to first and second files

commit 88206926cb60aed53d21ede69f9ca5b7c69cb983
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Sat Feb 19 09:23:47 2011 +0000

    My First Ever Commit
john@akira:~/coderepo$
</PRE>

<P>
The <TT>git log</TT> command shows us a chronological list of all of the commits to the repository and also gives us several more important pieces of information.  In total there are four pieces of information displayed by default.

<P>

<UL>
<LI><SPAN  CLASS="textbf">commit</SPAN> - This is the SHA-1 hash of the commit object that is stored inside the repository.  You can find more information about this in the <SPAN  CLASS="textit">What's inside the Git repository?</SPAN> section <SPAN  CLASS="textit">Week 2</SPAN>.  This is how we refer to the commit.  If someone asked you in what commit you <SPAN  CLASS="textit">Made a few changes to first and second files</SPAN>, you could reply that you did that in commit e86dd.  As explained earlier, it is good to remember that you don't need to remember or type out the whole <SPAN  CLASS="textbf">e86ddea25341a75275d316d8ca545aa7c73e97b3</SPAN>, only the first part is required.  Generally, the first five characters will do.
</LI>
<LI><SPAN  CLASS="textbf">Author</SPAN> - This is the name and email address of the author of the commit.  When we begin to look at merging, you will see that the author of a commit, is not necessarily the <SPAN  CLASS="textit">committer</SPAN> of the commit.  If you want to find out more about how to set these options, see the breakout box in this Week, called <SPAN  CLASS="textit">Changing your identity</SPAN>.
</LI>
<LI><SPAN  CLASS="textbf">Date</SPAN> - The date is simply the date at which the commit was created.  Again, note that when we start looking at merging, the date will be the date the commit was created, not the date it was merged into the repository.
</LI>
<LI><SPAN  CLASS="textbf">Commit Message</SPAN> - This is the log message that was added along with the commit when it was created.  Hopefully you can now see how important it is to create useful and meaningful messages in here.
</LI>
</UL>

<P>

<H3><A NAME="SECTION00511100000000000000">
Note on Commit IDs</A>
</H3>
Please note, that if you are following the commits and changes on your local computer, you may not and probably will not have the same commit IDs as are presented in this book.  You are advised to use them here to follow what is happening, but to substitue them with your own values, when you start working with the rest of this chapter.

<P>

<H3><A NAME="SECTION00511200000000000000">
Changing your identity</A>
</H3>
Particularly when working with other people, or when publishing your repository to a public location, it's a good idea to make sure people know who you are and how to get in contact with you.  Every time you make a commit to a repository, Git gives the opportunity to take note of who posted the commit.  When you first install Git, it probably won't have the correct information in there for you, so it's important that you take the time to set this up.

<P>
To set up your name and email address, we need to modify the <TT>gitconfig</TT> again.  

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
$ git config --global user.name "John Haskins"
$ git config --global user.email 
"john.haskins@tamagoyakiinc.koala"
</PRE>

<P>
That's it.  Now by default, Git will use this setting whenever you commit to a repository, unless you override it by locally modifying the repository's <TT>.gitconfig</TT>.

<P>

<H1><A NAME="SECTION00520000000000000000">
Day 2 - “But I need more information”</A>
</H1>

<H2><A NAME="SECTION00521000000000000000">
Digging a little deeper</A>
</H2>

<P><BLOCKQUOTE>In the trenches...
<BR>
<BR>“I know John, and next time I will make a note of it, but right now, I'd really like to know where this file got changed,” Klaus pointed at the piece of paper containing a print out, “specifically when this function was introduced.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John smiled.  His hands danced over the keyboard as he finished compiling an email.  “And you've no idea when this was added at all?” he asked.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“No, sorry John, I don't.”  He pondered, “I guess I could write a script to untar all the versions we've created in the last week and search through them.”  He sighed, “Can't the wonderful Git help us out here?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>A head popped up over the cubicle wall.  “You wanna find out when a function was introduced to a file?”  It was Rob.  “After John showed me the basics, I went and read up on it a little.  Git has some really powerful searching within the log tool.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well come on then,” blurted Klaus, “Don't keep me hanging on.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>A chime of the popular 1966 hit sprang out in the office.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Klaus pulled a hand down over his face, “Oh don't you all start!”
</BLOCKQUOTE>
<P>
Git can actually do some rather powerful searching to assist a developer in their daily tasks.  It would have been useful if the particular item that was being searched for had been included in the log, but sometimes, things either get missed, or there are just too many changes introduced in one commit to list them all.

<P>
In these instances, the <TT>git log -S&lt;string&gt;</TT> command comes to our aid.  This command will search through the commits in a repository and will return a list of commits which introduced or removed a specific string into the repository.  First of all, let's run this against our test repository.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log -SChange1
commit e86ddea25341a75275d316d8ca545aa7c73e97b3
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:06:57 2011 +0000

    Made a few changes to first and second files
john@akira:~/coderepo$
</PRE>

<P>
You can see that <TT>git log</TT> has shown us the commit that instantiated the change.  As you can imagine, when using a large code base, this tool can be invaluable.  It allows us to pinpoint a specific moment when a certain string of text entered the repository.  When running this against a very large repository, this could take a long time, and so the ability to shrink the search scope down will result in a much faster result.  To do this we can append a path to our previous command.  

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log -SChange2 my_first_committed_file
john@akira:~/coderepo$ git log -SChange2 my_second_committed_file
commit 6ca160c7226731bf80973fc5bc81f6b9beda7795
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:59:32 2011 +0000

    Finished adding initial files
john@akira:~/coderepo$
</PRE>

<P>
If you remember from our committing back in Week 2, we added the string <TT>Change2</TT> to the second file but not the first.  So the first time we run this command, it fails, as we are searching against <TT>my_first_committed_file</TT>.  The second time we run it, we are searching against <TT>my_second_committed_file</TT> and this is where we see a result.  Commit 6ca16 contains the commit we are looking for.

<P>

<H1><A NAME="SECTION00530000000000000000">
Day 3 - “So what actually changed?”</A>
</H1>

<H2><A NAME="SECTION00531000000000000000">
Doing the diff dance</A>
</H2>

<P>
Knowing what the committer thinks they committed is brilliant.  However, sometimes it's just not enough.  The reason for this is stated fairly precisely in the first sentance of this paragraph, so let us add a little formatting to being out the real meaning.  Knowing what the committer <SPAN  CLASS="textit">thinks</SPAN> they committed is brilliant.  By looking at the commit message we only know as much as the committer wants us to.  If they are the helpful sort, this will probably all that we need, most of the time.  On the other hand there is always the situation where you'd like to know a little more about what was actually placed into the repository.

<P>
The <TT>git diff</TT> command can show us exactly that.  For more infomation about diff in general, see the diff breakout box in this chapter.  Think of a diff as an easy way of looking at the differences between two files, surrounded by a little context.  This can often be enhanced by a visual diff viewer, but for now, let's stick with our simple text based <TT>git diff</TT>.  

<P>
If we want to find out what the changes are between our current commit and one of the previous ones, we can write a command like the one below.  Notice that below, <SPAN  CLASS="textbf">e86dd</SPAN> refers to the second commit that we made to the repository.  

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git diff e86dd
diff --git a/my_second_committed_file b/my_second_committed_file
index 3ad4cc3..095b9cd 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1 +1,2 @@
 Change1
+Change2
john@akira:~/coderepo$
</PRE>

<P>
What this is telling us, is that between <SPAN  CLASS="textbf">e86dd</SPAN> and our current commit <SPAN  CLASS="textbf">6ca16</SPAN>, we added the line <SPAN  CLASS="textit">Change2</SPAN> to the file <TT>my_second_committed_file</TT>.  We can see this by the preceeding <TT>+</TT> on the line <TT>Change2</TT>.  Let's make a few changes to our repository and see how the diffs look.  We're actually going to make a few changes to the files using a text editor so that you can't see what we've done.  Then, hopefully, when we run the <TT>git diff</TT> you'll be able to see clearly what has happened.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log HEAD~1..HEAD
commit fa65f06cc62291bb0cd47aef9e05953d6655fc8e
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Tue Mar 1 21:17:57 2011 +0000

    Messed with a few files
john@akira:~/coderepo$
</PRE>

<P>
The command <TT>git log HEAD&nbsp;1..HEAD</TT> tells Git to show us the git log for all commits between <TT>HEAD&nbsp;1</TT> and <TT>HEAD</TT>.  The notation used here is something new to us, but seeing as HEAD points to the most current commit, HEAD&nbsp;1 points to the commit previous to HEAD.  In this way, we are telling Git to show us only the most recently commit.  

<P>
As it turns out, John Haskins didn't really create a very meaningful log message.  <SPAN  CLASS="textit">Messed with a few files</SPAN> is pretty unhelpful in the grandscheme of things.  So let's be thankful that this isn't Tamagoyaki Inc's core repository and take a look at what actually happened in the commit <SPAN  CLASS="textbf">fa65f</SPAN>.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git diff HEAD~1..HEAD
diff --git a/my_second_committed_file b/my_second_committed_file
index 095b9cd..c9887f8 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1,2 +1 @@
-Change1
-Change2
+Changed this file completely
diff --git a/my_third_committed_file b/my_third_committed_file
new file mode 100644
index 0000000..5d27866
--- /dev/null
+++ b/my_third_committed_file
@@ -0,0 +1 @@
+Addition to the line
john@akira:~/coderepo$
</PRE>

<P>
As you can see, we have several things going on here, so let's take each of them in isolation and see what is going on.  We are going to disect the diff to see what each section means.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
diff --git a/my_second_committed_file b/my_second_committed_file
</PRE>

<P>
This first line tells us that we are dealing with <TT>my_second_committed_file</TT>.  This is showing that we are comparing the first revision, or a, against the second revision, b.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
index 095b9cd..c9887f8 100644
</PRE>

<P>
This second line actually tells us the beginning of the object IDs, as they are stored in the repository.  Note that these IDs are not the commit IDs, but the actual blob IDs that Git uses to refer to the file.  For more information on this, checkout the emphObject's living in harmony breakout box.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
--- a/my_second_committed_file
+++ b/my_second_committed_file
</PRE>

<P>
The next few lines are telling us which is the original file, and which is the new file, so we can use this as a reference.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
@@ -1,2 +1 @@
-Change1
-Change2
+Changed this file completely
</PRE>

<P>
The next bunch of lines are generally referred to as a hunk.  The hunk has two important pieces of information.  Section <TT>-1,2</TT> tells us that in the original file, we are looking at the original file (<TT>-</TT>), that the starting line where the change takes place is line 1 (<TT>1</TT>) and that the hunk applies to two lines (<TT>2</TT>).  The next section tells us that in the new file, the change takes place as line 1, and because the comma and remaining number are omitted, we can infer that the hunk applies to only 1 line.

<P>
The next three lines show what happened.  Strings <TT>Change1</TT> and <TT>Change2</TT> were deleted from the file, whereas <TT>Changed this file completely</TT> was added to the file.

<P>
Looking at the next diff segment, we can see it applies to a different file.  Essentially this hunk is no different to the last, the only interesting portion is shown below.

<P>
<PRE>[frame=single,fontsize=\relsize{-3}] 
new file mode 100644
index 0000000..5d27866
--- /dev/null
+++ b/my_third_committed_file
</PRE>

<P>
This shows us that <TT>my_third_committed_file</TT> is actually a new file.  Notice the <TT>/dev/null</TT> and the <TT>0000000</TT> object ID, indiciating that there was no original file.

<P>

<P>

<H1><A NAME="SECTION00540000000000000000">
Summary - John's Notes</A>
</H1>

<H2><A NAME="SECTION00541000000000000000">
Commands</A>
</H2>
<TT>git log</TT> - Return a navigatable list of commits to a repository

<P>
<TT>git log -S&lt;string&gt;</TT> - Show all commits that either introduced or removed a particular string from the repository

<P>
<TT>git log -S&lt;string&gt; &lt;path&gt;</TT> - Show all commits that either introduced or removed a particular string from the repository, but restrict the search to a specific path

<P>
<TT>git log HEAD&nbsp;1..HEAD</TT> - Show all commits between HEAD&nbsp;1 and HEAD, essentially the last commit

<P>
<TT>git diff HEAD&nbsp;1..HEAD</TT> - Show the actual differences between HEAD&nbsp;1 and HEAD

<P>

<H2><A NAME="SECTION00542000000000000000">
Terminology</A>
</H2>
<SPAN  CLASS="textbf">Branch</SPAN> - A way of working on the same set of code in parallel without modifications overlapping

<P>
<SPAN  CLASS="textbf">Diff</SPAN> - Shows the actual differences between files

<P>
<SPAN  CLASS="textbf">Hunk</SPAN> - A section of a diff output

<P>

<H1><A NAME="SECTION00600000000000000000">
Week 4</A>
</H1>

<H1><A NAME="SECTION00610000000000000000">
Day 1 - “Finally we're getting somehere”</A>
</H1>

<H2><A NAME="SECTION00611000000000000000">
Planting trees</A>
</H2>

<H1><A NAME="SECTION00700000000000000000">
Acknowledgements</A>
</H1>

<H1><A NAME="SECTION00710000000000000000">
“A Huge Thank You”</A>
</H1>

<P>

<H2><A NAME="SECTION00711000000000000000">
<SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> Support</A>
</H2>
These people provided invaluable <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> support:

<P>
Matthew Johnson

<P>
Ben Clifford

<P>

<H2><A NAME="SECTION00712000000000000000">
Git Support</A>
</H2>
#git on freenode

<P>

<H1><A NAME="SECTION00800000000000000000">
About this document ...</A>
</H1>
 <STRONG>Git In the Trenches</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2008 (1.71)
<P>
Copyright © 1993, 1994, 1995, 1996,
Nikos Drakos, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright © 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-html 4.0,unicode,latin1,utf8 -split 2 gitt.tex</TT>
<P>
The translation was initiated by pete on 2011-03-04
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html5"
  HREF="gitt.html#SECTION00100000000000000000">Contents</A>
<LI><A NAME="tex2html6"
  HREF="gitt.html#SECTION00200000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html7"
  HREF="gitt.html#SECTION00210000000000000000">How this book works</A>
</UL>
<BR>
<LI><A NAME="tex2html8"
  HREF="gitt.html#SECTION00300000000000000000">Week 1</A>
<UL>
<LI><A NAME="tex2html9"
  HREF="gitt.html#SECTION00310000000000000000">Day 1 - ``Things need to change''</A>
<UL>
<LI><A NAME="tex2html10"
  HREF="gitt.html#SECTION00311000000000000000">Meeting the Team</A>
<LI><A NAME="tex2html11"
  HREF="gitt.html#SECTION00312000000000000000">The trouble with storage</A>
</UL>
<LI><A NAME="tex2html12"
  HREF="gitt.html#SECTION00320000000000000000">Day 3 - ``A possible solution''</A>
<UL>
<LI><A NAME="tex2html13"
  HREF="gitt.html#SECTION00321000000000000000">Version Control Nuances</A>
<LI><A NAME="tex2html14"
  HREF="gitt.html#SECTION00322000000000000000">Distributed Version Control</A>
<LI><A NAME="tex2html15"
  HREF="gitt.html#SECTION00323000000000000000">Branching</A>
<LI><A NAME="tex2html16"
  HREF="gitt.html#SECTION00324000000000000000">Staging</A>
<LI><A NAME="tex2html17"
  HREF="gitt.html#SECTION00325000000000000000">Workflow</A>
<UL>
<LI><A NAME="tex2html18"
  HREF="gitt.html#SECTION00325100000000000000">Centralised Workflow</A>
<LI><A NAME="tex2html19"
  HREF="gitt.html#SECTION00325200000000000000">Integration Manager Workflow</A>
<LI><A NAME="tex2html20"
  HREF="gitt.html#SECTION00325300000000000000">Blessed</A>
<LI><A NAME="tex2html21"
  HREF="gitt.html#SECTION00325400000000000000">Dictator and Lieutenant Workflow</A>
</UL>
<LI><A NAME="tex2html22"
  HREF="gitt.html#SECTION00326000000000000000">Offline Committing</A>
<LI><A NAME="tex2html23"
  HREF="gitt.html#SECTION00327000000000000000">Developer Interaction</A>
<UL>
<LI><A NAME="tex2html24"
  HREF="gitt.html#SECTION00327100000000000000">Graphical User Interface Client (GUI)</A>
<LI><A NAME="tex2html25"
  HREF="gitt.html#SECTION00327200000000000000">Shell Extension Integration</A>
<LI><A NAME="tex2html26"
  HREF="gitt.html#SECTION00327300000000000000">Command Line Interface (CLI)</A>
</UL>
</UL>
<LI><A NAME="tex2html27"
  HREF="gitt.html#SECTION00330000000000000000">Day 4 - ``A decision is reached''</A>
<UL>
<LI><A NAME="tex2html28"
  HREF="gitt.html#SECTION00331000000000000000">Analysing Your Requirements</A>
</UL>
<LI><A NAME="tex2html29"
  HREF="gitt.html#SECTION00340000000000000000">Day 5 - ``Working like a team''</A>
<UL>
<LI><A NAME="tex2html30"
  HREF="gitt.html#SECTION00341000000000000000">Team Organisation</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html31"
  HREF="gitt.html#SECTION00400000000000000000">Week 2</A>
<UL>
<LI><A NAME="tex2html32"
  HREF="gitt.html#SECTION00410000000000000000">Day 1 - ``We are coders, we use Git!''</A>
<UL>
<LI><A NAME="tex2html33"
  HREF="gitt.html#SECTION00411000000000000000">Setting Up the Environment</A>
<LI><A NAME="tex2html34"
  HREF="gitt.html#SECTION00412000000000000000">Initialising A Repository</A>
<UL>
<LI><A NAME="tex2html35"
  HREF="gitt.html#SECTION00412100000000000000">What's inside the Git repository?</A>
</UL>
</UL>
<LI><A NAME="tex2html36"
  HREF="gitt.html#SECTION00420000000000000000">Day 2 - ``Making commitments''</A>
<UL>
<LI><A NAME="tex2html37"
  HREF="gitt.html#SECTION00421000000000000000">Let's Make a Repository</A>
<LI><A NAME="tex2html38"
  HREF="gitt.html#SECTION00422000000000000000">Committing the Uncommitted</A>
<LI><A NAME="tex2html39"
  HREF="gitt.html#SECTION00423000000000000000">How do we change the commit message editor?</A>
</UL>
<LI><A NAME="tex2html40"
  HREF="gitt.html#SECTION00430000000000000000">Day 4 - ``Let's do this right, not fast''</A>
<UL>
<LI><A NAME="tex2html41"
  HREF="gitt.html#SECTION00431000000000000000">Uh-Oh I Think I Made A Mistake</A>
</UL>
<LI><A NAME="tex2html42"
  HREF="gitt.html#SECTION00440000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html43"
  HREF="gitt.html#SECTION00441000000000000000">Commands</A>
<LI><A NAME="tex2html44"
  HREF="gitt.html#SECTION00442000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html45"
  HREF="gitt.html#SECTION00500000000000000000">Week 3</A>
<UL>
<LI><A NAME="tex2html46"
  HREF="gitt.html#SECTION00510000000000000000">Day 1 - ``But how do I see what's going on?''</A>
<UL>
<LI><A NAME="tex2html47"
  HREF="gitt.html#SECTION00511000000000000000">Logging in Git</A>
<UL>
<LI><A NAME="tex2html48"
  HREF="gitt.html#SECTION00511100000000000000">Note on Commit IDs</A>
<LI><A NAME="tex2html49"
  HREF="gitt.html#SECTION00511200000000000000">Changing your identity</A>
</UL>
</UL>
<LI><A NAME="tex2html50"
  HREF="gitt.html#SECTION00520000000000000000">Day 2 - ``But I need more information''</A>
<UL>
<LI><A NAME="tex2html51"
  HREF="gitt.html#SECTION00521000000000000000">Digging a little deeper</A>
</UL>
<LI><A NAME="tex2html52"
  HREF="gitt.html#SECTION00530000000000000000">Day 3 - ``So what actually changed?''</A>
<UL>
<LI><A NAME="tex2html53"
  HREF="gitt.html#SECTION00531000000000000000">Doing the diff dance</A>
</UL>
<LI><A NAME="tex2html54"
  HREF="gitt.html#SECTION00540000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html55"
  HREF="gitt.html#SECTION00541000000000000000">Commands</A>
<LI><A NAME="tex2html56"
  HREF="gitt.html#SECTION00542000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html57"
  HREF="gitt.html#SECTION00600000000000000000">Week 4</A>
<UL>
<LI><A NAME="tex2html58"
  HREF="gitt.html#SECTION00610000000000000000">Day 1 - ``Finally we're getting somehere''</A>
<UL>
<LI><A NAME="tex2html59"
  HREF="gitt.html#SECTION00611000000000000000">Planting trees</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html60"
  HREF="gitt.html#SECTION00700000000000000000">Acknowledgements</A>
<UL>
<LI><A NAME="tex2html61"
  HREF="gitt.html#SECTION00710000000000000000">``A Huge Thank You''</A>
<UL>
<LI><A NAME="tex2html62"
  HREF="gitt.html#SECTION00711000000000000000"><SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> Support</A>
<LI><A NAME="tex2html63"
  HREF="gitt.html#SECTION00712000000000000000">Git Support</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html64"
  HREF="gitt.html#SECTION00800000000000000000">About this document ...</A>
</UL>
<!--End of Table of Child-Links-->

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
pete
2011-03-04
</ADDRESS>
</BODY>
</HTML>
