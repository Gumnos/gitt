<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Git In the Trenches</TITLE>
<META NAME="description" CONTENT="Git In the Trenches">
<META NAME="keywords" CONTENT="gitt">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="gitt.css">

</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<P>
 =1000
=1000

<P>
<H1 ALIGN="CENTER">Git In the Trenches</H1>
<DIV CLASS="author_info">

<P ALIGN="CENTER"><STRONG>Peter Savage</STRONG></P>
<P ALIGN="CENTER"><STRONG>February 2011</STRONG></P>
</DIV>

<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html83"
  HREF="gitt.html#SECTION00200000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html84"
  HREF="gitt.html#SECTION00210000000000000000">How this book works</A>
</UL>
<BR>
<LI><A NAME="tex2html85"
  HREF="gitt.html#SECTION00300000000000000000">Week 1</A>
<UL>
<LI><A NAME="tex2html86"
  HREF="gitt.html#SECTION00310000000000000000">Day 1 - ``Things need to change''</A>
<UL>
<LI><A NAME="tex2html87"
  HREF="gitt.html#SECTION00311000000000000000">Meeting the Team</A>
<LI><A NAME="tex2html88"
  HREF="gitt.html#SECTION00312000000000000000">The trouble with storage</A>
</UL>
<LI><A NAME="tex2html89"
  HREF="gitt.html#SECTION00320000000000000000">Day 3 - ``A possible solution''</A>
<UL>
<LI><A NAME="tex2html90"
  HREF="gitt.html#SECTION00321000000000000000">Version Control Nuances</A>
<LI><A NAME="tex2html91"
  HREF="gitt.html#SECTION00322000000000000000">Distributed Version Control</A>
<LI><A NAME="tex2html92"
  HREF="gitt.html#SECTION00323000000000000000">Branching</A>
<LI><A NAME="tex2html93"
  HREF="gitt.html#SECTION00324000000000000000">Staging</A>
<LI><A NAME="tex2html94"
  HREF="gitt.html#SECTION00325000000000000000">Workflow</A>
<LI><A NAME="tex2html95"
  HREF="gitt.html#SECTION00326000000000000000">Offline Committing</A>
<LI><A NAME="tex2html96"
  HREF="gitt.html#SECTION00327000000000000000">Developer Interaction</A>
</UL>
<LI><A NAME="tex2html97"
  HREF="gitt.html#SECTION00330000000000000000">Day 4 - ``A decision is reached''</A>
<UL>
<LI><A NAME="tex2html98"
  HREF="gitt.html#SECTION00331000000000000000">Analysing Your Requirements</A>
</UL>
<LI><A NAME="tex2html99"
  HREF="gitt.html#SECTION00340000000000000000">Day 5 - ``Working like a team''</A>
<UL>
<LI><A NAME="tex2html100"
  HREF="gitt.html#SECTION00341000000000000000">Team Organisation</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html101"
  HREF="gitt.html#SECTION00400000000000000000">After Hours Week 1</A>
<UL>
<LI><A NAME="tex2html102"
  HREF="gitt.html#SECTION00410000000000000000">``History Lesson''</A>
<UL>
<LI><A NAME="tex2html103"
  HREF="gitt.html#SECTION00411000000000000000">A Brief History Of Version Control</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html104"
  HREF="gitt.html#SECTION00500000000000000000">Week 2</A>
<UL>
<LI><A NAME="tex2html105"
  HREF="gitt.html#SECTION00510000000000000000">Day 1 - ``We are coders, we use Git!''</A>
<UL>
<LI><A NAME="tex2html106"
  HREF="gitt.html#SECTION00511000000000000000">Setting Up the Environment</A>
<LI><A NAME="tex2html107"
  HREF="gitt.html#SECTION00512000000000000000">Initialising A Repository</A>
</UL>
<LI><A NAME="tex2html108"
  HREF="gitt.html#SECTION00520000000000000000">Day 2 - ``Making commitments''</A>
<UL>
<LI><A NAME="tex2html109"
  HREF="gitt.html#SECTION00521000000000000000">Let's Make a Repository</A>
<LI><A NAME="tex2html110"
  HREF="gitt.html#SECTION00522000000000000000">Committing the Uncommitted</A>
</UL>
<LI><A NAME="tex2html111"
  HREF="gitt.html#SECTION00530000000000000000">Day 4 - ``Let's do this right, not fast''</A>
<UL>
<LI><A NAME="tex2html112"
  HREF="gitt.html#SECTION00531000000000000000">Uh-Oh I Think I Made A Mistake</A>
</UL>
<LI><A NAME="tex2html113"
  HREF="gitt.html#SECTION00540000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html114"
  HREF="gitt.html#SECTION00541000000000000000">Commands</A>
<LI><A NAME="tex2html115"
  HREF="gitt.html#SECTION00542000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html116"
  HREF="gitt.html#SECTION00600000000000000000">After Hours Week 2</A>
<UL>
<LI><A NAME="tex2html117"
  HREF="gitt.html#SECTION00610000000000000000">``A Litte Of Git's Internals''</A>
<UL>
<LI><A NAME="tex2html118"
  HREF="gitt.html#SECTION00611000000000000000">A Look At Plumbing</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html119"
  HREF="gitt.html#SECTION00700000000000000000">Week 3</A>
<UL>
<LI><A NAME="tex2html120"
  HREF="gitt.html#SECTION00710000000000000000">Day 1 - ``But how do I see what's going on?''</A>
<UL>
<LI><A NAME="tex2html121"
  HREF="gitt.html#SECTION00711000000000000000">Logging in Git</A>
</UL>
<LI><A NAME="tex2html122"
  HREF="gitt.html#SECTION00720000000000000000">Day 2 - ``But I need more information''</A>
<UL>
<LI><A NAME="tex2html123"
  HREF="gitt.html#SECTION00721000000000000000">Digging a little deeper</A>
</UL>
<LI><A NAME="tex2html124"
  HREF="gitt.html#SECTION00730000000000000000">Day 3 - ``What actually changed?''</A>
<UL>
<LI><A NAME="tex2html125"
  HREF="gitt.html#SECTION00731000000000000000">Doing the diff dance</A>
<LI><A NAME="tex2html126"
  HREF="gitt.html#SECTION00732000000000000000">Diffing Over A Range</A>
</UL>
<LI><A NAME="tex2html127"
  HREF="gitt.html#SECTION00740000000000000000">Day 4 - ``Finding a good reference point''</A>
<UL>
<LI><A NAME="tex2html128"
  HREF="gitt.html#SECTION00741000000000000000">Tag you're it!</A>
</UL>
<LI><A NAME="tex2html129"
  HREF="gitt.html#SECTION00750000000000000000">Day 5 - ``Putting things back the way they were''</A>
<UL>
<LI><A NAME="tex2html130"
  HREF="gitt.html#SECTION00751000000000000000">Revert, I say. Revert!</A>
<LI><A NAME="tex2html131"
  HREF="gitt.html#SECTION00752000000000000000">Show me the money</A>
</UL>
<LI><A NAME="tex2html132"
  HREF="gitt.html#SECTION00760000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html133"
  HREF="gitt.html#SECTION00761000000000000000">Commands</A>
<LI><A NAME="tex2html134"
  HREF="gitt.html#SECTION00762000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html135"
  HREF="gitt.html#SECTION00800000000000000000">After Hours Week 3</A>
<UL>
<LI><A NAME="tex2html136"
  HREF="gitt.html#SECTION00810000000000000000">``A Closer Look At Diffs''</A>
<UL>
<LI><A NAME="tex2html137"
  HREF="gitt.html#SECTION00811000000000000000">Diff Algorithms</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html138"
  HREF="gitt.html#SECTION00900000000000000000">Week 4</A>
<UL>
<LI><A NAME="tex2html139"
  HREF="gitt.html#SECTION00910000000000000000">Day 1 - ``Finally we're getting somewhere''</A>
<UL>
<LI><A NAME="tex2html140"
  HREF="gitt.html#SECTION00911000000000000000">Planting trees</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html141"
  HREF="gitt.html#SECTION001000000000000000000">Acknowledgements</A>
<UL>
<LI><A NAME="tex2html142"
  HREF="gitt.html#SECTION001010000000000000000">``A Huge Thank You''</A>
<UL>
<LI><A NAME="tex2html143"
  HREF="gitt.html#SECTION001011000000000000000">Proofing and Ideas</A>
<LI><A NAME="tex2html144"
  HREF="gitt.html#SECTION001012000000000000000">L<SUP>A</SUP>TEX Support</A>
<LI><A NAME="tex2html145"
  HREF="gitt.html#SECTION001013000000000000000">Git Support</A>
</UL></UL></UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00200000000000000000">
Introduction</A>
</H1>

<H1><A NAME="SECTION00210000000000000000">
How this book works</A>
</H1>

<P>
Welcome to Git In The Trenches or GITT, a book designed to help you both apply and understand the subtleties of Git, perhaps the most powerful version control system in use today.  This book isn't supposed to be purely a technical reference, moreover it is hoped that the experiences and scenarios that you encounter will help give ways to apply Git in practical applications.  Git is a hugely powerful system and once harnessed you are most likely going to wonder how you managed without it.

<P>
GITT follows the lives of some developers at a fictional company called Tamagoyaki Inc.  They are a small software outfit who write bespoke software for people.  It may be that you work for a company that is very similar to Tamagoyaki Inc and you are looking to implement a version control system for your own company, or it could be that you have been using a version control for a long time.  Regardless of which box you fit into, GITT should provide you with some useful knowledge in a way that is designed to help you remember the scenarios and their associated solutions.

<P>
The book will follow the lead developer John, as he struggles to bring the company into line by implementing a version control system.  It's not something he's ever really used in earnest and he feels a little out of his depth.  It is hoped that your confidence and knowledge about both version control systems, and Git in particular, will grow whilst reading GITT.  

<P>
The chapters are presented as weeks during the implementation of Tamagoyaki Inc's VCS.  Each chapter spells a new week in the project and you will follow the life of John and his colleagues as they solve problems and learn tricks of the Git trade.  As well as presenting and solving common issues, the book will also be littered with breakout boxes, intended to tell you exactly what is happening inside Git at each stage.  This is intended to further your knowledge and understanding of this powerful piece of software.  At the end of each chapter are "John's Notes" which should build into a quick reference guide, also included with the book.

<P>
Often knowing the commands is not the only piece of the puzzle.  A good understanding of the underlying system, how it reacts when you press that all important «Enter» button, is essential if you want to be able to hold your cool in a crisis.  So let's start at Week 1 and find out why Tamagoyaki Inc even need a version control system.

<H1><A NAME="SECTION00300000000000000000">
Week 1</A>
</H1>

<H1><A NAME="SECTION00310000000000000000">
Day 1 - “Things need to change”</A>
</H1>

<H2><A NAME="SECTION00311000000000000000">
Meeting the Team</A>
</H2>

<P>
If you're already a seasoned version control user, you may want to skip this chapter.  It's kind of like an introduction to why we even need version control systems in the first place.  This chapter looks at Tamagoyaki Inc's requirements and why they choose the VCS that seemed right for them.  Tamagoyaki Inc. create software for turning a standard PC into a media center.  Their product ships to the end user and they rely very heavily on having a good presense at trade shows, in order to bring in sales.  The following conversation describes the events that led up to the defining "We need a VCS!" discussion.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>John sat at his desk and looked out of the window.  The rain was drizzling down the pane, but he didn't care.  It was a quiet Monday morning, the release had gone well on Friday and John was just thinking about implementing the new abstraction layer to the database he'd been asked for.  Through the music playing in his headphones he hardly noticed his boss, the chief designer and the CEO approaching his desk.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“John,” shouted his boss, Markus, “get your team into the board room.  Now!”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Things didn't look good. 
</BLOCKQUOTE>
<P><BLOCKQUOTE>
<DIV ALIGN="CENTER">
* * * 

</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, what we'd like to know John, is just how a bug that was supposed to have been...” the CEO back-tracked, “that was demonstrated as being fixed two weeks ago, made it into the final release of the software?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I'm sorry,” John started, before being cut off.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Sorry doesn't cut it John,” said the CEO, Wayne Tobi, “This was almost a major embarrassment for Tamagoyaki Inc.  We need to ensure this doesn't happen again.  The demonstration at the trade show was close to a complete failure.  Luckily someone had the good sense to bring a backup machine.”  He turned to Markus.  “I want a report on my desk by the end of the day that states what the problem was, how it slipped through our fingers and what safe guards we are going to put into place so that things like this never happen again.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Of course sir,” Markus replied.  He was bright red with his own variety of embarrassment.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The room fell silent and a few minutes of silence passed before the meeting was drawn to a close and John and his team were allowed to leave.
</BLOCKQUOTE>
<P><BLOCKQUOTE>
<DIV ALIGN="CENTER">
* * * 

</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, you're telling me that when Simon came back from holiday, he picked up an older copy of the library from the network share and pushed his latest code into that?”  Markus was holding back the anger.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“It appears that way.”  Said John sullenly.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Oh for crying out loud.  How did this happen?  Why wasn't he using the latest version?  And why didn't QA pick up on it?”  Markus looked across the meeting room at John.  “John, you need to make sure this doesn't happen again.  Find a solution!”
</BLOCKQUOTE>
<P>

<H2><A NAME="SECTION00312000000000000000">
The trouble with storage</A>
</H2>

<P>
It's not like this situation is completely uncommon.  At one point or another most people have managed to pull old code from somewhere and mistakenly use it in place of the latest, up to date, version.  When storing code on network shares or on local disks, it's easy to lose sight of which version is which, no matter how good your naming convention is.  It's like trying to build one of the baked bean puzzles when you have three boxes of them and you tipped all the pieces into one box for simplicities sake.  Not so simple any more is it?

<P>
People have a tendency to use folder names which mean something to them.  However it doesn't necessarily follow that this name means something to another developer.  “Version 2.3 - fixed bug a” only means something to you if you know what bug a is and something like “Version 2.3 - fixed bug a(2)” is even worse.  Unfortunately allowing people to free form type their own descriptive file names will always lead to problems like this.  When these files are stored on a network share, the problem is exacerbated ten fold because there is often no fixed reference point.

<P>
So what's the solution?  Well, in a large number of cases version control can make sure that not only is there a defined place for data to sit, and with a defined structure, but also that you have a full history of the code.  Accountability is very important in code development, especially when releasing software to customers.  In some situations a customer will even mandate that the code being developed for them is stored in a version controlled environment.  In this way, the customer can ask when a certain piece of code was edited, or when an addition first entered the code base.

<P>

<H1><A NAME="SECTION00320000000000000000">
Day 3 - “A possible solution”</A>
</H1>

<H2><A NAME="SECTION00321000000000000000">
Version Control Nuances</A>
</H2>

<P>
There are many offerings for version control out there, Git, Mercurial, Subversion, CVS, and Bazaar to name but a few of the open source ones.  Perhaps a more pertinent question is just which version control system to use.  Each of them has their relative advantages and disadvantages, but some will be suited to certain tasks more than others.  Also, it's worth noting that if you are interacting with other pieces of software, or share some development with another set of developers, it is a good idea to enquire to see what they are using.  Usually you'll find collaboration, forking and patching a lot easier if you're using the same version control system as your upstream or partners.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“So really it seems like the only real solution to this problem bar Klaus' suggestions of reducing the workforce to only one developer, thank you Klaus,” Klaus nodded in acknowledgement back to John, “is to implement a version control system.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Markus chewed his lip.  “I can see where you're coming from here John, but aren't version control systems really expensive?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“There are a number of open source offerings we could take a look at first,” piped up a new voice in the discussion, “some of them are supposed to be pretty good.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Let's all go away, take a look at the various pros and cons and reconvene tomorrow to discuss the findings,” said John.  “Sound fair?”
</BLOCKQUOTE>
<P>
So now we need to take a look at some various features of version control systems and see what the various advantages and disadvantages are of each.  We are going to focus on Git here primarily, as this is what the rest of the book is all about.  It is assumed that if you are reading this book, you have most likely already made the decision about which version control system you are going to use.  So let's talk about the various features that are prevalent in most version control systems.

<P>

<H2><A NAME="SECTION00322000000000000000">
Distributed Version Control</A>
</H2>

<P>
Version control systems usually fit into one of two categories; centralised, or distributed.  Git is a distributed version control system.  It has been designed to run almost everything at a local level.  This will become much more clear when we talk about other features of Git a little later on, but for now just understand that Git isn't tied to a centralised repository.  This is super powerful.  No Really!

<P>

<H2><A NAME="SECTION00323000000000000000">
Branching</A>
</H2>

<P>
Most version control systems offer branching as part of their default features set.  Branching allows developers to create in essence a clone of their repository and mess around with it, safe in the knowledge that they can switch back to the original whenever they need to.  This allows developers the freedom to experiment with all manner of things without being afraid of affecting the original/clean code base.

<P>
Git implements branching in a special way.  Most other version control systems implement branching in a way that almost creates a separate repository.  This is slow and cumbersome.  Git's branching method gives developers the ability to create multiple local branches to play with.  Due to it's distributed nature, when pushing code to a more central location for others to pull from, developers can choose which branches they want to push, allowing code to be experimented with privately.

<P>
The implementation of branching in Git is fast.  Due to the fact that repositories are stored locally, the speed of creating a local branch is limited only by the speed of the disks on a local machine.

<P>

<H2><A NAME="SECTION00324000000000000000">
Staging</A>
</H2>

<P>
Git deals with commits differently to most other version control systems by introducing the staging area.  The staging area allows developers to prepare their commits before they are written to the repository.  Why is this useful or any different to any other version control system.  In Git you can make a change to a file, add it to the staging area, and then continue to make changes to that file, even though you have not yet actually committed anything.
It should be noted that it's not absolutely necessary to use the staging area, but it is there for developers wishing to utilise it.

<P>

<H2><A NAME="SECTION00325000000000000000">
Workflow</A>
</H2>

<P>
Due to the way that Git has been designed, it's possible to use it in practically any work flow you can think of.  Three of the most common workflows are explained below, and Git can work in any of these, making it one of the more versatile systems out there.

<P>

<H3><A NAME="SECTION00325100000000000000">
Centralised Workflow</A>
</H3>

<P>
In a centralised workflow, a single shared repository is used.  Multiple developers pull changes from here into local working copies, work on the local version, and then push it back up to the central location.  

<P>
Git handles this workflow just like most other version control systems.  A developer can not push his changes until he has pulled everything up to the latest from the central repository and resolved any conflicts that may arise.

<P>
Using the centralised model for the workflow, each developer has the same level of access to the repository and is considered as <SPAN  CLASS="textbf">important</SPAN> as each other.  For smaller teams, this method will work well, but as teams get larger, a centralised method may get tedious.

<P>

<DIV ALIGN="CENTER"><A NAME="136"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .1:</STRONG>
Centralised Workflow</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>	</TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00325200000000000000">
Integration Manager Workflow</A>
</H3>
The integration manager workflow is similar to the centralised workflow because there is still a <SPAN  CLASS="textbf">blessed</SPAN> repository which everyone uses as a reference.  The difference here is that there is only one person who has the rights to push changes to the <SPAN  CLASS="textbf">blessed</SPAN> repository.  This person is referred to as the Integration Manager.  

<P>
This workflow is handled exceedingly well by Git.  Developers will work on their repositories locally and then once they are happy, will push their changes to a location where the Integration Manager can see them.  The Integration Manager will then review the changes that the developers have made and will merge them into their own local repository.  Once they are happy that everything is working well, the Integration Manager will push their changes to the blessed repository so that all the other developers can access the changes.

<P>

<DIV ALIGN="CENTER"><A NAME="143"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .2:</STRONG>
Integration Manager Workflow</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>	</TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00325300000000000000">
Dictator and Lieutenant Workflow</A>
</H3>

<P>
The dictator and lieutenant workflow is practically an extension to the integration manager workflow.  It is more suited to larger teams, where modules or sections of the code can be assigned to a <SPAN  CLASS="textbf">Lieutenant</SPAN> who is responsible for blessing all of the changes to that particular section.

<P>
Once the Lieutenants are happy with their code, they make it available to the Dictator.  The Dictator then takes on a role similar to the Integration Manager from the previous model.  In the end, all of the changes are pushed to the blessed repository for the developers at the bottom of the tree to pull from.

<P>

<DIV ALIGN="CENTER"><A NAME="149"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .3:</STRONG>
Dictator and Lieutenant Workflow</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>	</TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER">
mybox = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
fancytitle =[fill=black, text=white]
<BR>
<IMG
 WIDTH="254" HEIGHT="151" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="\begin{tikzpicture}
\node [mybox] (box){%
\begin{minipage}{.9\textwidth}
A bles...
... rounded corners] at (box.west) {\rotatebox{90}{Terminology}};
\end{tikzpicture}">
</DIV>

<P>
The main thing to remember, is that Git can utilise any of these workflows.  This makes it a very flexible system, allowing you to work in whichever way you decide.

<P>

<H2><A NAME="SECTION00326000000000000000">
Offline Committing</A>
</H2>

<P>
Perhaps one of the most useful and undervalued features of version control systems is that of offline committing.  It may be undervalued because not all version control systems have it.  Offline committing is the ability to continue adding and committing files to the repository without being connected to a centralised repository.  

<P>
When travelling or just simply when out of the office, developers and integrators alike are able to continue managing code, viewing histories, viewing diffs and committing changes to their repository.  This is all due to the fact that Git does 99% of all of it's operations locally.  When a repository is cloned, Git actually sets up a copy of the entire repository locally, giving developers the flexibility to work anywhere, without requiring access to the company network.

<P>
When returning to the office, the developers simply push their changes to their “public” space, be it local or to a blessed location, and all of the commits that have been made whilst they are away are then made available to the rest of the team, including all history and snapshots.

<P>

<H2><A NAME="SECTION00327000000000000000">
Developer Interaction</A>
</H2>

<P>
One factor to consider when choosing a version control system, is that of developer interaction.  By this we are referring to the way in which developers use and interact with the version control system itself.  There are four main methods for VCS interaction

<P>

<H3><A NAME="SECTION00327100000000000000">
Graphical User Interface Client (GUI)</A>
</H3>

<P>
A graphical user interface allows the developer, or user, to physically manipulate the repository using a mouse pointer and a graphically rich environment.  A GUI client will typically consist of separate application which is run when a user wants to make changes to a repository such as adding files or committing changes.  

<P>
Some developers prefer having a separate client with which to interact with their repository, whilst others prefer to have things integrated a little more.

<P>

<H3><A NAME="SECTION00327200000000000000">
Shell Extension Integration</A>
</H3>

<P>
Shell integration allows the user to interact with their repository using the graphical environment that they would usually use for manipulating files and performing routine directory maintenance.  One of the most common Shell Extensions for Git is the TortoiseGit interface which integrates itself into Windows Explorer, allowing a user to right click on an entity whilst inside a git working tree, and be presented with a context sensitive menu for VCS operations.

<P>

<H3><A NAME="SECTION00327300000000000000">
Command Line Interface (CLI)</A>
</H3>

<P>
The command line interface is favour by many developers as they can script with it and can see exactly what is going on, often in much more detail that with a GUI.  The CLI gives total control over the product and it is worth noting that almost all version control systems start life as command line driven interfaces.  Why is this so?  It can take a lot of time and effort to put all the options and nuances of a system into a GUI.  The CLI will almost always be the most powerful of all tools, especially where version control systems are concerned.

<P>

<H1><A NAME="SECTION00330000000000000000">
Day 4 - “A decision is reached”</A>
</H1>

<P>

<H2><A NAME="SECTION00331000000000000000">
Analysing Your Requirements</A>
</H2>

<P>
The most important aspect of choosing a version control system, is to define your requirements.  These can be few, or they can be quite specific, let's see what John and his team decide are the most important aspects for them and ultimately what they decide upon.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“Offline committing seems like it's a pretty useful thing to have.”  Mike said nodding.  “Especially with people like John travelling all the time.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I have to admit, it would be nice to be on the plane, and be able to pull all the code together, knowing all of the history of each section,” replied John.  “The branching in Git seems to be quite powerful as well.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I must admit,” chimed in Klaus, “I've used branching a bit in Subversion before and it was a lifesaver.  It's supposed to be super fast in Git too.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“And owing to the fact that Git seems to support several workflows, it means we can try them out and see how they work for us.”  Markus looked at the team.  “Are we settled on Git then?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The team nodded and everyone walked out of the board room except John.  Things were about to get interesting for him.  Very interesting.
</BLOCKQUOTE>
<P>
Since this book is all about Git, we won't delve too far into the workings or features of other version control systems.  Hopefully, this chapter has given you enough information to go and check out some of the other systems, if you feel the need to.  The main thing to bear in mind is that Git is a Distributed Version Control system.  While this is so, it is equally important to remember that it can be used in the same workflow models as Centralised Version Control systems.

<P>
John and his teams requirements are nothing special.  They are a smallish team looking to reap the benefits of having their code in a well organised system.  They are also looking to reorder their team functions and dynamics in order to fit around the version control system and really make it core to their development.  

<P>
Version control is not a replacement for workflow.  It is not intended to make everything better.  If you have people going off and doing their own thing and being careless about the way they work, version control is not going to suddenly fix everything.  A tool is just that, a tool and version control is no different.  You can buy the messiest builder in the trade a nice shiny new tool box, but unless they have the mindset to want to change, you'll probably find that all the tools end up in the largest compartment at the bottom.

<P>

<H1><A NAME="SECTION00340000000000000000">
Day 5 - “Working like a team”</A>
</H1>

<P>

<H2><A NAME="SECTION00341000000000000000">
Team Organisation</A>
</H2>

<P>
Now that we have the basics dealt with, let's take a little look at how John arranges his team, and see whether version control is going to work for them.  It is important that the team understands how the model should work, what they are expected to do and what level of access they have.  Most of the time people will get more frustrated about not know what they should or shouldn't be doing, rather than that they do or don't have access to certain things.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>It was 4:36pm on the Friday and the table in the board room was littered with empty coke cans, pizza boxes and one Japanese bento lunchbox, owned by a particularly stubborn member of the team who had vowed never to eat pizza again.  It had been Marcus' idea to bring in the food reinforcement to help the discussions along.  The team were trying to decide how to organise their model.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“There's nothing to say we can't use a combination of the models is there?” asked Mike.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I suppose not,” said John.  “What did you have in mind.”  His glasses were slipping down his forehead now and he was getting pretty tired.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well, I figure, we basically have the software split into two parts.  We have the library, which myself, Klaus and Jack work on.  Then there's the UI elements which Simon, Martha and Rob handle.  I know there are the tools which Eugene works on too.”  Everyone had started to listen to Mike as he continued.  “John, you don't want to have to deal with the library component as this more Klaus' space.  So why don't we have two dictators.  Klaus and yourself have access to push up to the blessed repository.  John can pull from his guys, Klaus from his and we end up with an good model for version control.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John raised his eyebrows, “Not bad Mike,” he said, genuinely impressed.  After spending a few hours going through the various models and who was  in charge of what, it felt good to have finally reached a decision.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, we start on Monday then?” asked Markus, who had been listening from the other end of the table.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Indeed.”  Announced Klaus, “Monday we all become Gits!”
</BLOCKQUOTE>
<H1><A NAME="SECTION00400000000000000000">
After Hours Week 1</A>
</H1>

<H1><A NAME="SECTION00410000000000000000">
“History Lesson”</A>
</H1>

<H2><A NAME="SECTION00411000000000000000">
A Brief History Of Version Control</A>
</H2>

<P>

<H3><A NAME="SECTION00411100000000000000">
The Very Early Days</A>
</H3>
Version control systems have been around for forty years (2011 at the time of writing).  During this time they have undergone an intense amount of change and have evolved into some of the most incredibly powerful tools utlised in software development today.  Chances are that in the early days you will have started off storing different versions of your source code and documents in separate files and folders.  You may have even archived them off to compressed storage files, like zip or tar.  Rest assured, you are not the first person to do this, and in 1972, someone called Marc J. Rochkind, decided to create system for storing revisions of documents and source code.

<P>
The system Marc created was called SCCS and stood for Source Code Control System, in essence probably the most apt description for what we mainly use a version control system for today.  SCCS was originally written for an operating system called OS/360 MVT and was later ported to C, and was used as the most dominant version control system for UNIX, until ten years later, when RCS was introduced.

<P>

<H3><A NAME="SECTION00411200000000000000">
Time To Move On</A>
</H3>
In 1982, Walter F. Tichy released RCS, standing for Revision Control System.  It was intended to be a free and off more functionality than SCCS.  RCS is still being maintained, as part of the GNU project, and at the time of writing is about to have its first new release, version 5.8, in over fifteen years.

<P>
However, RCS, like it's predecessor SCCS, has no way of dealing with groups of files.  Essentially, each file has its own repository which is stored near to the file under a different name.  Whilst rather advanced, with primitive forms of branching, the interface, commands and version numbering have been described by some as rather cumbersome.  Enter some successors.

<P>
CVS was created in 1986, and began life as a set of shell scripts to operate on multiple files, using RCS to perform the actual repository management.  As development continued, this way of working was dropped and CVS began operating on files itself, evolving into a version control system in its own right.  The current iteration of CVS was released in 1989 and on Novermber 1 1990, version 1.0 was released to the Free Software Foundation for distribution.

<P>
CVS did not version file renames or moves at all as at the time, refactoring - a process of modifying code to improve some non-functional attributes of the software, was often avoided and so the feature was not required.  CVS also did not support atomic commits.  An atomic commit is used by more modern version control systems to safe guard the database.  In essence atomic committing is the act of applying multiple changes in a single operation.  If any of the changes do not apply correctly, all others are reverted and the commit is aborted.  When designing CVS this was not seen as an obstacle, as it was thought by the developers that a server and network should have enough resilience that it would never crash whilst committing.

<P>
Whilst active development of CVS has apparently ceased, as of May 2008, it is worth taking note that CVS defined the model for branching that was included and refined in almost all version control systems since.  

<P>

<H3><A NAME="SECTION00411300000000000000">
Offering Commercial Support</A>
</H3>
Now that version control was advanced enough and people had begun to rely on VCSs in general, commercial offerings began to spring up.  Three prominant systems that were released within a short time of each other and ClearCase, VSS and Perforce.  All three of these are proprietary systems which were developed and filled a gap in the market for commercially supported systems.  

<P>
VSS, originally developed by One Tree Software for several platforms, was continually developed by Microsoft, who bought One Tree Software in 1994, with the one caveat that Microsoft ceased development of all VSS on all platforms other than Windows.  VSS integrated into Visual Studio, Microsoft's Integrated Development Environment.  VSS has now ceased developement, but ClearCase, now developed by a divison of IBM, and Perforce are still being actively developed and maintained.

<P>

<H3><A NAME="SECTION00411400000000000000">
The Millenium</A>
</H3>
The millenium brought with it a new breed of version control systems.  Subversion, or SVN as it is colloquially known as, was developed primarily to be a replacement and mostly compatible successor to CVS.  SVN was first released in 2000 and by 2001 was able to sufficiently host its own source code due to its own advancement.  In November 2009 Subversion was accepted into the Apache group and is currently developed and maintained by its community and by several commercial entities.

<P>
Subversion brought things to the table that previous version control systems did not.  As it was released as free software, in the same vein as CVS, it was widely adopted by the open source community and later into commercial environments for its vastly improved feature set.  For a start SVN offers true atomic commits.  This gave it a definite advantage over CVS as it was seen as a truly robust alternative.

<P>
It also brought in features like the tracking of files through renames and moves, including their entire version history and the versioning of symbolic links.  SVN moved with the times and introduced many other sought after features, such as HTTP serving, cheaper branching, efficient network operation and native support for binary files.  

<P>
As with all version control systems, there are aspects that people dislike.  In Subversion, people often fine the implementation of tags - names that point to specific points in the history of a repository, an issue.  In SVN, a tag is actually a branch.  What makes this different to other systems such as Git and its predecessor CVS, which literally point to a specific commit in the tag, SVN actually creates a snapshot of the filesystem, albeit using cheap branching.  Whilst this is lightweight on the repository, it is incredibly heavyweight on the client.

<P>
Another issue with the tagging model in SVN is that it holds no history information.  This makes it impossible, for example, to take two tags and try to find out all logged commits that occurred from one to the other.  This is the difference between using a copy as a tag, and implementing a reference.  Tags should also be read-only implicitly by their very nature, they should refer to a point in history.  However as tags are implemented as branches in SVN this is not the case.

<P>

<H3><A NAME="SECTION00411500000000000000">
Introducing the Linus Factor</A>
</H3>
The Linux kernel was at one point maintained under a source control system called BitKeeper.  The decision, in 2002, to use BitKeeper for the management of the Linux kernel source was rather controversial, the main opposition being that BitKeeper was a proprietary system that was offered by BitMover.  At the time, BitMover offered certain open source projects the opportunity to use BitKeeper at no cost, so long as the community developers did not engage in the creation of a competing tool.

<P>
In April 2005, BitKeeper withdrew the free license that it had granted to the open source communities, after allegations of reverse engineering by some parties on an unrelated project.  Due to the way BitKeeper worked, and decisions made regarding licensing it became impossible for several key developers, including Linus himself, of actually owning even a commercial version of BitKeeper.

<P>
It was due to these circumstances, that Linus Torvalds himself, decided to begin writing his own version control system that would enable him to have all of the features that he had had available to him with BitKeeper, the most important of these seemingly being a distributed environment.  Linus decided on a set of criteria, which along with a distributed environment, also included a robust safeguard against corruption, be it accidental, or malicious, and very high performance.

<P>
Git developement began on the 3rd of April 2005, and by April the 7th, the project had been announced and was already able to host itself.  On June 16th, the relese of the Linux kernel version 2.6.12 was managed by Git.  Junio Hamano, who had been a major contributor to the project, took over maintenance of Git in July, and by December had released version 1.0 to the community.

<P>
Interestingly enough, another project was also created as a result of this chain of events.  Mercurial or Hg as it is often known, began development on April 19th of the same year and was started by Matt Mackall with largely the same goals as Git.  Though Git was chosen to be the version control system used by the Linux kernel, Mercurial is actively used by many other projects and shares a very similar design and concept to Git.

<P>

<H3><A NAME="SECTION00411600000000000000">
Design Changes</A>
</H3>
Git has some features which should be discussed here as many of them are different to every other version control system.  Perhaps one of the most important of these is the very strong emphasis on non-linear development.  Git provides many tools with which to work with many branches and merges, with a core principal being that changes will often be passed around more than they will be written.

<P>
Git is very fast.  Though for certain operations it may be slower than some of its peers, Git has been consistently proven to be faster than most.  This design implementation was essential as the Linux kernel is indeed a very large project.  

<P>
When developing systems that offer any kind of security to an end user, it is essential to provide a way of auditing the history of the code, to ensure that no tampering has taken place.  Due to the way that Git is implemented, each SHA-1 hash, used to identify a particular commit, depends on the entire history of the repository.  What does this mean to someone viewing the repository?  Once the repository is published, it is impossible for someone to tamper with the history without someone noticing.  This is called cryptographic authentication of history.

<P>
Of course the most important feature, and one which will be discussed in great detail later in the book, is that of distributed development.  The emphasis on non-linear development and the implementation of very cheap and fast branching, makes Git one of the best version control systems on the market for distributed development.

<P>
As mentioned previously every version control system has advantages and disadvantages and it would not be fair to make out that Git was without flaws.  Some that have been mentioned by people over the years are its particular steep learning curve for basic understanding.  Whilst it is agreeable to some degree, it is largely due to the fact that Git is a distributed version control system and inherently these systems are more complex in their implementation that others.  Another bug bear of some people, is the fact that Git will not track empty directories.  

<P>

<H3><A NAME="SECTION00411700000000000000">
Wrapping Up</A>
</H3>
Though there are many other version control systems out there that are being actively developed, such as Bazaar, Plastic and Dars, to name but a few, we are going to end our historical tale here and continue with learning more about the Git version control system.  There is a plethora of information available on the Internet about version control, so if you want to find more information about any of the systems mentioned here, that would probably be the best place to start.

<H1><A NAME="SECTION00500000000000000000">
Week 2</A>
</H1>

<H1><A NAME="SECTION00510000000000000000">
Day 1 - “We are coders, we use Git!”</A>
</H1>

<H2><A NAME="SECTION00511000000000000000">
Setting Up the Environment</A>
</H2>

<P>
So now we are ready to begin delving into and actually using Git, right?  Well, not exactly.  First we have to decide upon how the workflow model we have envisaged is implemented in our version control system.  With Git being so versatile, it's both a blessing and a danger.  It is a good idea to define from early on, exactly how you would like the developers, lieutenants and dictators to behave, before you begin actually committing any code.  Sometimes this isn't possible.  It's quite feasible that you have never used a version control system like Git before and you begin by muddling your way through.  This is normal, but if you are in charge of implementing this type of system for a professional environment, you should really consider first how this is going to work. 

<P>
Conceptually, the model which was discussed previously is easy to imagine.  We have two dictators, who both have access to the blessed repository and then several developers, who are going to have their changes reviewed and included, by the aforementioned dictators.  The physical representation of the workflow model is summarised in the diagram below.

<P>

<DIV ALIGN="CENTER"><A NAME="443"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure .1:</STRONG>
Tamagoyaki Inc's Physical Structure</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
The physical structure is all well and good, but it doesn't determine exactly how the data is moved, just who is responsible for it at each stage in the process.  What is required, is a detailed analysis of where the data flows from and to.  A data flow diagram is useful, but not essential.  However, we will create a slightly different form of diagram to show how the data will be moved from one person to another.  Before we go ahead and look at the diagram, let's go back to the trenches to see how the guys are coping with their repository design. 

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“John, why are we all sat in here at 9:45am on Monday morning.”  Klaus whined.  “I haven't even ingested enough coffee to check emails yet, let alone meet with people.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John grinned, “I don't think any amount of coffee will help you there Klaus, it's you winning personality that will pull you through.”  The rest of the team laughed and then subsided as John started drawing furiously on the board.  “So we have our physical model.  We know which people are going to be in charge of things, but we don't know yet how to arrange our repositories.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Good point,” chimed Mike. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So.  Obviously we're going to have a blessed repository,” said John, drawing a circle on the board.  He stepped back, one hand on chin.  “Then I would imagine Klaus and I will have clones of that repository on our local machines.  We will then modify those and push our changes back up to the central copy.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I thought Git didn't have a central copy?” asked Martha.  There were other moans and grunts. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well,” said John, “as far as I understand it, it doesn't.  I mean Klaus and I will have local copies of the repository too.  We will work on those and then sync our changes back to the server.  It's a sync, moreover a copy.  I think it's actually called a clone.”  He nodded to himself, “And, since Klaus and I will hardly ever overlap on code, we shouldn't ever need to merge or deal with an conflicts.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“But what about us monkeys?” asked Martha, “Where do we get our clones from?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“From the central server of course,” Rob stated smiling. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Yes,” John said, “but I think what Martha is trying to say, is how will you get your updates?”  He started to walk around the room, and one or two of the developers followed him as he reached the windows and leant on the sill.  “I guess you would merge your branch with the blessed one.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The room went silent and the only noise that could be heard was the rattling of the air conditioner in the ceiling above. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Simon spoke out, “Well, I was reading over the weekend about this thing called rebase and how in some cases a rebase is better than merging.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“What's rebase and how is it different to merging?” asked Mike. 
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well, rebasing is pretty darn clever.  Think of it this way.  You have an upstream branch, in this case, our blessed repository.  You are happily making changes.  When the upstream changes, you could merge the changes in from blessed.  If you do this, you create a single commit which merges the changes in.  It works, but...” he trailed off a little, “it can cause problems in certain instances.  A better way to handle it is with rebasing.  Rebasing can take all the changes you have made, squirrel them away, pull down all the changes to bring it up to date, and then whack your changes on top.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John breathed out, “It sounds pretty cool Simon, but one thing is abundantly clear, we need to learn more about the Git basics before we start delving into this merging and rebasing.  Let's spend the rest of the day playing with some test repositories and reconvene tomorrow.”
</BLOCKQUOTE>
<P>
If you've never played with a version control system before it is a good idea to take some time to just play.  Pretty soon you'll have learnt the basics and will be in a position where you will want to put your newly honed skills into practise.  Though playing on test repositories is good, it is quite usual that you need to actually use the system in a real environment before real problems arise.  The rest of this chapter is a very quick introduction to Git.  It is presented as an introduction, because it is hoped and expected that the you will take some time out to get to know the system and how it works. 

<P>

<H2><A NAME="SECTION00512000000000000000">
Initialising A Repository</A>
</H2>
The first thing we need to do is to understand two very important things: 

<P>

<OL>
<LI>How to create a Git repository 
</LI>
<LI>What a Git repository actually is 
</LI>
</OL>

<P>
The first of these is relatively easy to perform.  

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}]
john@akira:~$ mkdir coderepo 
john@akira:~$ cd coderepo 
john@akira:~/coderepo$ git init 
Initialized empty Git repository in /home/john/coderepo/.git/ 
john@akira:~/coderepo$ git
</PRE>

<P>
What we've done here is create a new directory called coderepo, moved into it, and then run the git init command.  The result of this command is a new directory in the coderepo directory called .git.  This directory will hold a local copy of our entire repository.  This will allow us to create branches, merge changes, rebase things and ultimately push our changes to somewhere else.

<P>
Something that is crucial to the running of a repository, whether you are an administrator of Git, or a developer who is using it, is an understanding of how Git works.  It is fine to jump in and play with the repository and test the water, but before committing to using Git in a production environment, you should understand what Git actually does in the background in some detail. 

<P>
During the writing of this book several people have told me that Git is one of the only version control systems where a good understanding of how the underlying system works is not just highly recommended, but bordering on essential. 

<P>
Let us take a few minutes to talk about how Git works internally and how the data is actually stored.  Git doesn't store changes to files, but actual snapshots of files at specific points in time.  It refers to these by running an SHA-1 hash against the file.  By doing this, it is easy to Git to detect if a file has changed.  If the SHA-1 hash of a file changes, then the file must have been modified. 

<P>
When a commit is made to the repository, Git stores a few things.  A commit object is created.  This contains information about who made the commit, the parent of the commit and points to a tree object.  The tree object describes what the repository looked like at the time of the commit.  In other words the tree object, tells Git what files were in there.  Lastly, Git stores the files that were in the repository under their SHA-1 names in the objects directory.  Of course Git is super clever here because if you have exactly the same file in multiple commits, the SHA-1 hash of that file doesn't change and therefore Git only stores one copy of the file to save space.

<P>
The commit object is also referred to by an SHA-1 hash.  This is different to many other version control systems which use either a number that refers to the repository or a per file version number.  Getting used to seeing 40 character SHA-1 hashes can take a little time.  Saying "I need the commit referred to as  bf81617d6417d9380e06785f8ed23b247bea8f6d," is certainly not as easy as saying you need revision 6.  However, Git handles these hashes well, and you can reference a commit using a few of the characters from the beginning, as long as those characters uniquely refer to that commit, i.e., as long as your choice isn't in any way ambiguous.

<P>

<H1><A NAME="SECTION00520000000000000000">
Day 2 - “Making commitments”</A>
</H1>

<H2><A NAME="SECTION00521000000000000000">
Let's Make a Repository</A>
</H2>

<P>
The most simple way of committing a file into the repository is to create it, or bring it into your working copy and use the commands below.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/touch my_first_committed_file
john@akira:~/coderepo$ touch my_first_committed_file
john@akira:~/coderepo$ git add my_first_committed_file
john@akira:~/coderepo$ git commit -m 'My First Ever Commit'
[master (root-commit) 8820692] My First Ever Commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 my_first_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
What we have done here, is to create a new blank file and add it into the repository using Git's add command.  Then we have committed it into the repository.  Let's make a few changes to our working copy and see what the result is.  First we are going to add another two new files, then we are going to make changes to our original file and finally we are going to run git status to see what Git has to say about our changes.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ echo "Change1" &gt; my_first_committed_file 
john@akira:~/coderepo$ touch my_second_committed_file
john@akira:~/coderepo$ touch my_third_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in 
working directory)
#
#	modified:   my_first_committed_file
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_second_committed_file
#	my_third_committed_file
no changes added to commit (use "git add" and/or "git commit 
-a")
john@akira:~/coderepo$
</PRE> 

<P>
So we can see that Git is reporting that there are changes to our first committed file, and that our second and third files are <SPAN  CLASS="textbf">untracked</SPAN>.  Untracked files are ones which Git detects as being present in the working directory, but which haven't yet been added and there for upon running a commit, these files will not be added to the repository.  Notice that if we tried to run a commit now, nothing would actually be committed to the repository.  Even though there are changes to to my_first_committed_file, we have not asked Git to include these.  So, let's go ahead and do that, and at the same time we'll make a few changes to my_second_committed_file, and add those too.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git add my_first_committed_file
john@akira:~/coderepo$ echo "Change1" &gt; my_second_committed_file 
john@akira:~/coderepo$ git add my_second_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	modified:   my_first_committed_file
#	new file:   my_second_committed_file
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
Now we can see that one of the sections has changed to "Changes to be committed".  So this means that Git has recognised and remembered that we are expecting these files to be committed when we next run a git commit.  

<P>

<H2><A NAME="SECTION00522000000000000000">
Committing the Uncommitted</A>
</H2>

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“John, what is going on here?” shouted Klaus from across the hallway.  The entire office had heard Klaus banging his hands down on the desk for the last fifteen minutes.  “John!” the shout turned into a scream.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Calm down Klaus, I'm just coming.”  John walked over to Klaus and pulled up one of the folding plastic chairs.  After a few minutes of fumbling he finally managed to take up his position next to an infuriated Klaus.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“John, Git is driving me crazy.  I have added files to the repository and I keep running a commit, but the changes aren't getting put into the blasted repo.”  Klaus was clearly distressed and John resisted the urge make jokes.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John pointed at the screen.  “Run a git status Klaus and I'll show you what the problem is.”
</BLOCKQUOTE>
<P>
To understand what Klaus was getting in a spin about, let's make a change to my_second_committed_file now and see how this affects things.  Remember we have already added the file, but we haven't yet made a commit.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ echo "Change2" &gt;&gt; 
my_second_committed_file 
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	modified:   my_first_committed_file
#	new file:   my_second_committed_file
#
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in 
working directory)
#
#	modified:   my_second_committed_file
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
How interesting!  We now have three sections and one of our files appears twice under both Changes to be committed and Changed but not updated.  What does this mean?  If you remember back, we spoke about a staging area.  This is one area in which Git differs to many version control systems.  When you <SPAN  CLASS="textbf">add</SPAN> a file into the repository, Git will actually make a copy of that file and move it into the staging area.  If you then go ahead and change that file, you would need to run another git add in order for Git to copy your changed file into the staging area.  The most important thing to remember is that Git will only ever commit what is in the staging area.

<P>
So, if we go ahead and run our commit now, we will only have the changes marked in Changes to be committed appearing in our repository.  

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git commit -m 'Made a few changes to 
first and second files'
[master e86ddea] Made a few changes to first and second files
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 my_second_committed_file
john@akira:~/coderepo$
</PRE> 

<P>
In our examples, we have used the syntax <TT>git commit -m 'Message'</TT>.  This is a slightly special way of committing, it allows us to specify our commit log message on the command line.  If we wanted to, we could run the command git commit and this would open a text editor that we could use to input our commands.

<P>
Let us finish off our round of committing by using the <TT>git commit -a</TT> option.  This commits all of the changes to files which are already tracked.  Consequently we do not have to specify the files with <TT>git add</TT>, like we have had to previously.  Any file which has been modified and has previously been added to the repository, will have it's changes committed upon running that command.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status 
# On branch master 
# Changed but not updated: 
#   (use "git add &lt;file&gt;..." to update what will be committed) 
#   (use "git checkout -- &lt;file&gt;..." to discard changes in 
working directory) 
# 
#	modified:   my_second_committed_file 
# 
# Untracked files: 
#   (use "git add &lt;file&gt;..." to include in what will be 
committed) 
# 
#	my_third_committed_file 
no changes added to commit (use "git add" and/or "git commit 
-a")
</PRE> 

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git commit -a -m 'Finished adding initial 
files' 
[master 6ca160c] Finished adding initial files 
 1 files changed, 1 insertions(+), 0 deletions(-)
</PRE> 

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status 
# On branch master 
# Untracked files: 
#   (use "git add &lt;file&gt;..." to include in what will be 
committed) 
# 
#	my_third_committed_file 
nothing added to commit but untracked files present (use "git 
add" to track) 
john@akira:~/coderepo$
</PRE> 

<P>

<H1><A NAME="SECTION00530000000000000000">
Day 4 - “Let's do this right, not fast”</A>
</H1>

<P>

<H2><A NAME="SECTION00531000000000000000">
Uh-Oh I Think I Made A Mistake</A>
</H2>

<P>
So now we are fairly well acquainted with adding files into the repository and performing commits.  In a short while we will learn about how to view the changes we have made and perform diffs against various objects.  Before we close out the week, we need to go back to the trenches one last time.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“Rob, ya got a second?” asked Mike.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Sure, what's up?” replied Rob from across the office.  “Gimme two secs to make this commit.”  The office went silent again whilst Rob's fingers darted across the keyboard.  “Ahh.  Damn it!” shouted Rob.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Mike rose from his chair and walked over to Rob.  “What's up?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I just added a file into the staging area, but I don't want it there.”  He shook his head, “Well not yet anyway.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Mike chuckled, “Sorry for interrupting dude.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Nah, it's OK, I just need to know how to pull this file out of the index.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Git reset,” shouted a voice.  The stillness of the office was interrupted by a chair free wheeling across the floor.  The occupant of the chair was Klaus.  He seemed proud that he was finally getting to grips with things.  “You can use git reset to reset a file that's in the index.”  He grabbed at the keyboard, “Here, lemme show you.”
</BLOCKQUOTE>
<P>
The git reset is great at removing things from the index that you don't want to be there.  Of course, it can do a great many other things, but for now, let us concern ourselves with the scenario presented above.  We are working away, and have added a number of files into the index ready for committing, when we discover that we are actually not ready to commit them.  In the following example, we are going to add the file my_third_committed_file and then remove it from the index.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git add my_third_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	new file:   my_third_committed_file
#
john@akira:~/coderepo$
</PRE> 

<P>
Notice how my_third_committed_file is now ready to be committed to repository.  The problem is we need to add something more to it before we do.  Remember that when we run the git add command, we are copying the file from our working copy to the index.  If we decide we no longer want that file in the repository, we can run the following.  

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git reset my_third_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
nothing added to commit but untracked files present (use "git 
add" to track)
john@akira:~/coderepo$
</PRE>

<P>
We have discarded the file which was residing in the index.  This is very important to note.  We are not moving the file from the index back into our working directory, we are literally just deleting the file from the index.  Our working copy remains unaffected.  We could run the git reset command without appending a file.  If we did this, all the files in the index would have been discarded.  

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“So, I think we are all agreed, I'll keep a version of the repository under Git version control.  Until everyone else feels comfortable with some of the more advanced features.”  John looked around the room for any disagreements but there were none.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Agreed John,” said Markus, “I'm pleased with how you guys are progressing, very pleased, but like John said, it's far better for us to take our time and to implement this correctly, than to rush it and to end up with something that we can't administrate and that we don't know how it works.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So next week, I want you all to start playing with diffing and logs and don't forget we have an important release due too.”  John pushed his glasses further up his nose.  “The week after that we'll start looking at branching and by then we may be at the stage where we can implement our model.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Everyone nodded in agreement.
</BLOCKQUOTE>
<P>

<DIV ALIGN="CENTER">
mybox = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
fancytitle =[fill=black, text=white]
<BR>
<IMG
 WIDTH="516" HEIGHT="427" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="\begin{tikzpicture}
\node [mybox] (box){%
\begin{minipage}{.9\textwidth}
We spo...
...e, rounded corners] at (box.west) {\rotatebox{90}{Knowledge}};
\end{tikzpicture}">
</DIV>

<P>
We have run through a few basic commands in Git.  If you are familiar with version control systems, then possibly the only real difference you will have noticed is that of the staging area.  It really is powerful, and allows you to organise and prepare your commits, so that they are both meaningful and coherent.

<P>
For Tamagoyaki Inc, their plan to implement version control was far too aggressive.  Most of the members of the team had never even used a version control system.  When deciding to implement version control, it is essential to ensure that you are doing it for the right reasons.  Version control is a tool to help you to keep things in order, but remember tools are nothing without process.  It is process that is key to the order.

<P>

<H1><A NAME="SECTION00540000000000000000">
Summary - John's Notes</A>
</H1>

<H2><A NAME="SECTION00541000000000000000">
Commands</A>
</H2>

<UL>
<LI><TT>git add</TT> - Add files into the index or staging area

<P>
</LI>
<LI><TT>git commit </TT> - Commit files into the repository, using text editor for commit message

<P>
</LI>
<LI><TT>git commit -m '&lt;Message&gt;'</TT> - Commit files into the repository, using the command line to supply commit message

<P>
</LI>
<LI><TT>git commit -a</TT> - Commit all tracked files into the repository that have changed, using text editor for commit message

<P>
</LI>
<LI><TT>git reset &lt;path&gt;</TT> - Remove file from index or staging area

<P>
</LI>
<LI><TT>git status</TT> - Show the status of tracked, changed, untracked files
</LI>
</UL>

<P>

<H2><A NAME="SECTION00542000000000000000">
Terminology</A>
</H2>

<UL>
<LI><SPAN  CLASS="textbf">Branch</SPAN> - A way of working on the same set of code in parallel without modifications overlapping

<P>
</LI>
<LI><SPAN  CLASS="textbf">Commit</SPAN> - A group of objects and a tree in a Git repository
</LI>
</UL>

<H1><A NAME="SECTION00600000000000000000">
After Hours Week 2</A>
</H1>

<H1><A NAME="SECTION00610000000000000000">
“A Litte Of Git's Internals”</A>
</H1>

<H2><A NAME="SECTION00611000000000000000">
A Look At Plumbing</A>
</H2>

<P>
Talking about objects, trees, commits 

<P>
Let's take a brief look into the directory structure, to see what this command has created in the <TT>.git</TT> folder.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo/.git$ ls -la 
total 40 
drwxr-xr-x 7 john john 4096 2011-02-17 19:23 . 
drwxr-xr-x 3 john john 4096 2011-02-17 19:23 .. 
drwxr-xr-x 2 john john 4096 2011-02-17 19:23 branches 
-rw-r--r-- 1 john john   92 2011-02-17 19:23 config 
-rw-r--r-- 1 john john   73 2011-02-17 19:23 description 
-rw-r--r-- 1 john john   23 2011-02-17 19:23 HEAD 
drwxr-xr-x 2 john john 4096 2011-02-17 19:23 hooks 
drwxr-xr-x 2 john john 4096 2011-02-17 19:23 info 
drwxr-xr-x 4 john john 4096 2011-02-17 19:23 objects 
drwxr-xr-x 4 john john 4096 2011-02-17 19:23 refs 
john@akira:~/coderepo/.git$
</PRE> 

<P>
<SPAN  CLASS="textbf">branches</SPAN> - Though deprecated now, this folder stores shorthands for git pull, push and fetch commands, by creating a file, the name of which is passed to the command instead of the repository argument.

<P>
<SPAN  CLASS="textbf">config</SPAN> - This is the main configuration file for Git.  It is the first place git looks for upon invocation.  If this file is not present, Git will inspect&nbsp;/.gitconfig.  After this, Git will go to /etc/gitconfig.  The file holds information about the remotes, tracking branches, push configurations and many more items.

<P>
<SPAN  CLASS="textbf">description</SPAN> - This is a simple text file which gives a description to a repository when being view via gitweb or similar.

<P>
<SPAN  CLASS="textbf">HEAD</SPAN> - This file is a pointer to the parent commit of your current branch.

<P>
<SPAN  CLASS="textbf">hooks</SPAN> - Scripts can be placed in here to perform operations at certain points during the commit process.

<P>
<SPAN  CLASS="textbf">info</SPAN> - The info folder contains some additional information about the repository

<P>
<SPAN  CLASS="textbf">objects</SPAN> - The is the directory that holds all of the actual files that are stored in the repository.  The files are named by their SHA-1 values.  Inside the folder are a number of directories which make up the first 2 characters of the SHA-1 value.  The remaining portion of the SHA-1 hash is used to name the file.

<P>
<SPAN  CLASS="textbf">refs</SPAN> - This folder holds the files that files for local branches, remote branches and tags.

<P>
More files and folders may appear here during the running of the repository.

<H1><A NAME="SECTION00700000000000000000">
Week 3</A>
</H1>

<H1><A NAME="SECTION00710000000000000000">
Day 1 - “But how do I see what's going on?”</A>
</H1>

<H2><A NAME="SECTION00711000000000000000">
Logging in Git</A>
</H2>

<P>
Perhaps the best feature of a version control system is the level of accountability that it offers if set up correctly.  What do we mean by this?  People often mistake the word <SPAN  CLASS="textbf">accountability</SPAN> for the word <SPAN  CLASS="textbf">blame</SPAN>.  This is not true at all.  Accountability is key in understanding the events that led up to a particular bug being introduced, or a situation occurring.  How this is dealt with, is a up to the management teams, but accountability should not be something that is revered, it should be something that is looked upon as a tool to help define the cause of a problem.

<P>
By its very nature, a version control system is also a logging system.  Every time we committed something into the repository in the last chapter, we supplied a log message.  In fact, if we don't supply a commit message, let us see what happens.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be 
committed)
#
#	my_third_committed_file
nothing added to commit but untracked files present (use "git 
add" to track)
john@akira:~/coderepo$ git add my_third_committed_file
john@akira:~/coderepo$ git commit -a -m ''
Aborting commit due to empty commit message.
john@akira:~/coderepo$
</PRE>

<P>
Git will actually not allow you to commit with a blank message.  This is actually fantastic news, as people are far less likely to write a useless message than they are a blank one.  It is very important that when using a version control system you write in a useful commit message.  If you fixed a bug, say so.  If you added a new function, why not put that in too.  When someone wants to find out what a certain commit was for, or even when you come back to the project six months later and realise you've forgotten everything, log messages are crucial in piecing back together a history of development.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“So John, I've been committing and all that,” started Rob, “but how do I see the history of what I have done.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“It's really pretty simple,” replied John, “But it really depends on what you want to know.”
Rob placed his thumb and forefinger onto his chin.  “Well, for now, I just want to see a list of all of my commits.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“That one's the simplest of all.”
</BLOCKQUOTE>
<P>
At its simplest, <TT>git log</TT> will give an output of all of the commits that have been applied to the current branch.  Depending on what type of machine you are using it on, the output from <TT>git log</TT> will be navigable, usually using the up and down arrows, with 'q' used to quit.  Let's have a quick look at the output of our test repository and see what the log messages look like.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log
commit 6ca160c7226731bf80973fc5bc81f6b9beda7795
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:59:32 2011 +0000

    Finished adding initial files

commit e86ddea25341a75275d316d8ca545aa7c73e97b3
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:06:57 2011 +0000

    Made a few changes to first and second files

commit 88206926cb60aed53d21ede69f9ca5b7c69cb983
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Sat Feb 19 09:23:47 2011 +0000

    My First Ever Commit
john@akira:~/coderepo$
</PRE>

<P>
The <TT>git log</TT> command shows us a chronological list of all of the commits to the repository and also gives us several more important pieces of information.  In total there are four pieces of information displayed by default.

<P>

<UL>
<LI><SPAN  CLASS="textbf">commit</SPAN> - This is the SHA-1 hash of the commit object that is stored inside the repository.  You can find more information about this in the <SPAN  CLASS="textit">What's inside the Git repository?</SPAN> section <SPAN  CLASS="textit">Week 2</SPAN>.  This is how we refer to the commit.  If someone asked you in what commit you <SPAN  CLASS="textit">Made a few changes to first and second files</SPAN>, you could reply that you did that in commit e86dd.  As explained earlier, it is good to remember that you don't need to remember or type out the whole <SPAN  CLASS="textbf">e86ddea25341a75275d316d8ca545aa7c73e97b3</SPAN>, only the first part is required.  Generally, the first five characters will do.
</LI>
<LI><SPAN  CLASS="textbf">Author</SPAN> - This is the name and email address of the author of the commit.  When we begin to look at merging, you will see that the author of a commit, is not necessarily the <SPAN  CLASS="textit">committer</SPAN> of the commit.  If you want to find out more about how to set these options, see the breakout box in this Week, called <SPAN  CLASS="textit">Changing your identity</SPAN>.
</LI>
<LI><SPAN  CLASS="textbf">Date</SPAN> - The date is simply the date at which the commit was created.  Again, note that when we start looking at merging, the date will be the date the commit was created, not the date it was merged into the repository.
</LI>
<LI><SPAN  CLASS="textbf">Commit Message</SPAN> - This is the log message that was added along with the commit when it was created.  Hopefully you can now see how important it is to create useful and meaningful messages in here.
</LI>
</UL>

<P>

<DIV ALIGN="CENTER">
mybox = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
fancytitle =[fill=black, text=white]
<BR>
<IMG
 WIDTH="251" HEIGHT="109" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="\begin{tikzpicture}
\node [mybox] (box){%
\begin{minipage}{.9\textwidth}
Please...
...ytitle, rounded corners] at (box.west) {\rotatebox{90}{Note}};
\end{tikzpicture}">
</DIV>

<P>

<DIV ALIGN="CENTER">
mybox = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
fancytitle =[fill=black, text=white]
<BR>
<IMG
 WIDTH="259" HEIGHT="380" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="\begin{tikzpicture}
\node [mybox] (box){%
\begin{minipage}{.9\textwidth}
Partic...
...ytitle, rounded corners] at (box.west) {\rotatebox{90}{Note}};
\end{tikzpicture}">
</DIV>

<P>

<H1><A NAME="SECTION00720000000000000000">
Day 2 - “But I need more information”</A>
</H1>

<H2><A NAME="SECTION00721000000000000000">
Digging a little deeper</A>
</H2>

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“I know John, and next time I will make a note of it, but right now, I'd really like to know where this file got changed,” Klaus pointed at the piece of paper containing a print out, “specifically when this function was introduced.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John smiled.  His hands danced over the keyboard as he finished compiling an email.  “And you've no idea when this was added at all?” he asked.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“No, sorry John, I don't.”  He pondered, “I guess I could write a script to untar all the versions we've created in the last week and search through them.”  He sighed, “Can't the wonderful Git help us out here?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>A head popped up over the cubicle wall.  “You wanna find out when a function was introduced to a file?”  It was Rob.  “After John showed me the basics, I went and read up on it a little.  Git has some really powerful searching within the log tool.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well come on then,” blurted Klaus, “Don't keep me hanging on.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>A chime of the popular 1966 hit sprang out in the office.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Klaus pulled a hand down over his face, “Oh don't you all start!”
</BLOCKQUOTE>
<P>
Git can actually do some rather powerful searching to assist a developer in their daily tasks.  It would have been useful if the particular item that was being searched for had been included in the log, but sometimes, things either get missed, or there are just too many changes introduced in one commit to list them all.

<P>
In these instances, the <TT>git log -S&lt;string&gt;</TT> command comes to our aid.  This command will search through the commits in a repository and will return a list of commits which introduced or removed a specific string into the repository.  First of all, let's run this against our test repository.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log -SChange1
commit e86ddea25341a75275d316d8ca545aa7c73e97b3
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:06:57 2011 +0000

    Made a few changes to first and second files
john@akira:~/coderepo$
</PRE>

<P>
You can see that <TT>git log</TT> has shown us the commit that instantiated the change.  As you can imagine, when using a large code base, this tool can be invaluable.  It allows us to pinpoint a specific moment when a certain string of text entered the repository.  When running this against a very large repository, this could take a long time, and so the ability to shrink the search scope down will result in a much faster result.  To do this we can append a path to our previous command.  

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log -SChange2 my_first_committed_file
john@akira:~/coderepo$ git log -SChange2 my_second_committed_file
commit 6ca160c7226731bf80973fc5bc81f6b9beda7795
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Mon Feb 21 20:59:32 2011 +0000

    Finished adding initial files
john@akira:~/coderepo$
</PRE>

<P>
If you remember from our committing back in Week 2, we added the string <TT>Change2</TT> to the second file but not the first.  So the first time we run this command, it fails, as we are searching against <TT>my_first_committed_file</TT>.  The second time we run it, we are searching against <TT>my_second_committed_file</TT> and this is where we see a result.  Commit 6ca16 contains the commit we are looking for.

<P>

<H1><A NAME="SECTION00730000000000000000">
Day 3 - “What actually changed?”</A>
</H1>

<H2><A NAME="SECTION00731000000000000000">
Doing the diff dance</A>
</H2>

<P>
Knowing what the committer thinks they committed is brilliant.  However, sometimes it's just not enough.  The reason for this is stated fairly precisely in the first sentence of this paragraph, so let us add a little formatting to bring out the real meaning.  Knowing what the committer <SPAN  CLASS="textit">thinks</SPAN> they committed is brilliant.  By looking at the commit message we only know as much as the committer wants us to.  If they are the helpful sort, this will probably be all that we need, most of the time.  On the other hand there is always the situation where you'd like to know a little more about what was actually placed into the repository.

<P>
The <TT>git diff</TT> command can show us exactly that.  For more information about diff in general, see the diff breakout box in this chapter.  Think of a diff as an easy way of looking at the differences between two files, surrounded by a little context.  This can often be enhanced by a visual diff viewer, but for now, let's stick with our simple text based <TT>git diff</TT>.  

<P>
If we want to find out what the changes are between our current commit and one of the previous ones, we can write a command like the one below.  Notice that below, <SPAN  CLASS="textbf">e86dd</SPAN> refers to the second commit that we made to the repository.  

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git diff e86dd
diff --git a/my_second_committed_file b/my_second_committed_file
index 3ad4cc3..095b9cd 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1 +1,2 @@
 Change1
+Change2
john@akira:~/coderepo$
</PRE>

<P>
What this is telling us, is that between <SPAN  CLASS="textbf">e86dd</SPAN> and our current commit <SPAN  CLASS="textbf">6ca16</SPAN>, we added the line <SPAN  CLASS="textit">Change2</SPAN> to the file <TT>my_second_committed_file</TT>.  We can see this by the preceding <TT>+</TT> on the line <TT>Change2</TT>.  Let's make a few changes to our repository and see how the diffs look.  We're actually going to make a few changes to the files using a text editor so that you can't see what we've done.  Then, hopefully, when we run the <TT>git diff</TT> you'll be able to see clearly what has happened.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log HEAD~1..HEAD
commit fa65f06cc62291bb0cd47aef9e05953d6655fc8e
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Tue Mar 1 21:17:57 2011 +0000

    Messed with a few files
john@akira:~/coderepo$
</PRE>

<P>
The command <TT>git log HEAD&nbsp;1..HEAD</TT> tells Git to show us the git log for all commits between <TT>HEAD&nbsp;1</TT> and <TT>HEAD</TT>.  The notation used here is something new to us, but seeing as HEAD points to the most current commit, HEAD&nbsp;1 points to the commit previous to HEAD.  This is how we tell Git to show us only the most recently commit.  

<P>
As it turns out, John Haskins didn't really create a very meaningful log message.  <SPAN  CLASS="textit">Messed with a few files</SPAN> is pretty unhelpful in the grand scheme of things.  So let's be thankful that this isn't Tamagoyaki Inc's core repository and take a look at what actually happened in the commit <SPAN  CLASS="textbf">fa65f</SPAN>.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git diff HEAD~1..HEAD
diff --git a/my_second_committed_file b/my_second_committed_file
index 095b9cd..c9887f8 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1,2 +1 @@
-Change1
-Change2
+Changed this file completely
diff --git a/my_third_committed_file b/my_third_committed_file
new file mode 100644
index 0000000..5d27866
--- /dev/null
+++ b/my_third_committed_file
@@ -0,0 +1 @@
+Addition to the line
john@akira:~/coderepo$
</PRE>

<P>
As you can see, we have several things going on here, so let's take each of them in isolation and see what is going on.  We are going to dissect the diff to see what each section means.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
diff --git a/my_second_committed_file b/my_second_committed_file
</PRE>

<P>
This first line tells us that we are dealing with <TT>my_second_committed_file</TT>.  This is showing that we are comparing the first revision, or a, against the second revision, b.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
index 095b9cd..c9887f8 100644
</PRE>

<P>
This second line actually tells us the beginning of the object IDs, as they are stored in the repository.  Note that these IDs are not the commit IDs, but the actual blob IDs that Git uses to refer to the file.  For more information on this, checkout the <SPAN  CLASS="textit">Object's living in harmony</SPAN> breakout box.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
--- a/my_second_committed_file
+++ b/my_second_committed_file
</PRE>

<P>
The next few lines are telling us which is the original file, and which is the new file, so we can use this as a reference.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
@@ -1,2 +1 @@
-Change1
-Change2
+Changed this file completely
</PRE>

<P>
The next bunch of lines are generally referred to as a hunk.  The hunk has two important pieces of information.  Section <TT>-1,2</TT> tells us that in the original file, we are looking at the original file (<TT>-</TT>), that the starting line where the change takes place is line 1 (<TT>1</TT>) and that the hunk applies to two lines (<TT>2</TT>).  The next section tells us that in the new file, the change takes place as line 1, and because the comma and remaining number are omitted, we can infer that the hunk applies to only 1 line.

<P>
The next three lines show what happened.  Strings <TT>Change1</TT> and <TT>Change2</TT> were deleted from the file, whereas <TT>Changed this file completely</TT> was added to the file.

<P>
Looking at the next diff segment, we can see it applies to a different file.  Essentially this hunk is no different to the last, the only interesting portion is shown below.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
new file mode 100644
index 0000000..5d27866
--- /dev/null
+++ b/my_third_committed_file
</PRE>

<P>
This shows us that <TT>my_third_committed_file</TT> is actually a new file.  Notice the <TT>/dev/null</TT> and the <TT>0000000</TT> object ID, indicating that there was no original file.

<P>

<H2><A NAME="SECTION00732000000000000000">
Diffing Over A Range</A>
</H2>
All the operations that we have performed so far have been on one commit.  Whilst important and valuable, it may be that you want to see an entire range of changes.  

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“I'm still not entirely convinced about this John,” said Martha.  “I've been playing around with Git, like you asked me, but it still just seems like we're replicating the work that we used to do with the readme changelogs and the tarball files.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>She sat down on a near-by chair and wheeled it over to John's desk.  She surveryed the desk for an inch of vacant real estate before finally resting her elbow on the corner of his desk next to a copy of Pro Git.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well, actually Martha, I can see exactly what you mean.  Up until now, there is no difference between the old and the new process.  I'm still in control of all the versions, so nothing has really changed.”  He thought long and hard, “Tell ya what.  Why don't you give me an operation that you've always wanted to do against our code tree tarballs easily.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Easy,” she snapped back, “I want to know what changes were made for the last two weeks whilst I had been away on holiday.” She smiled an almost mischevious smile as she referenced 'The Incident', as it had become known throughout the office.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Easy,” John quipped, mimicking her mannerisms.  The two broke out in laughter.  “We can use git log for that, and I think there are some date options too.  Let me check the man page.”
</BLOCKQUOTE>
<P>
Looking at the man page for git log is a mind trip for the uninitiated.  Weighing in at over 600 lines of text, it is abundantly clear that this tool does a whole lot more than viewing a simple history of commits to the repository.  It is well worth taking the time to read through the current available options by typing <TT>man git log</TT> on the command line.  If you have the documentation installed, this will yield the <SPAN  CLASS="textit">man</SPAN> page for <TT>git log</TT>.

<P>
Listing all commits in our repository is useful, being able to filter this output is fantastic.  This is one area in which the developers of Git have placed a great deal of time and effort.  For example, we can use <TT>git log</TT> to not only show us the commit message, but also provide a diff output as well.  This means that for each commit entry in the output, we will see a diff as well.  Now, whilst we are further empowered by having the diff output in chronological order for each commit, we can take things further by filtering the commits.  

<P>
Suppose we want to view all the commits that we made in the last week, typing the following into the comand line in our test repository yields the following result.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log -p --since="last week"
commit fa65f06cc62291bb0cd47aef9e05953d6655fc8e
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Tue Mar 1 21:17:57 2011 +0000

    Messed with a few files

diff --git a/my_second_committed_file b/my_second_committed_file
index 095b9cd..c9887f8 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1,2 +1 @@
-Change1
-Change2
+Changed this file completely
diff --git a/my_third_committed_file b/my_third_committed_file
new file mode 100644
index 0000000..5d27866
--- /dev/null
+++ b/my_third_committed_file
@@ -0,0 +1 @@
+Addition to the line
john@akira:~/coderepo$
</PRE>

<P>
Notice we get to see the diff that was presented before when we ran our <TT>git diff HEAD&nbsp;1..HEAD</TT> command, but this time, as we have used the git log command instead, we get to see the diff output as well.  This is what the <TT>-p</TT> flag is for.  Take note of the way we have specified the time period that we are interested in.  The section <TT>-since="last week"</TT> tells Git to filter the output and show only the entries that were committed within the last week.

<P>
This type of filtering can be exceedingly useful to a developer.  Often when problems arise, you do not have a defined point in time that you know it was last working.  However most of the time, you can say with some certainty, “I know it was working two weeks ago”.  Using the methods descibed above, will give the user all of the changes, categorised by commit, that occured in those two weeks, allowing them to narrow down the scope of exactly where to begin looking for the offending changes.

<P>
If the developer can futher categorise the issue, such as, “I know which file the change must have occured in”, then the following example will demonstrate just how easy it is to filter the results even further.  Even in the simplified example repository that we have been using, running this command filters the output to a single file.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git log -p --since="last week" -- 
my_second_committed_file
commit fa65f06cc62291bb0cd47aef9e05953d6655fc8e
Author: John Haskins &lt;john.haskins@tamagoyakiinc.koala&gt;
Date:   Tue Mar 1 21:17:57 2011 +0000

    Messed with a few files

diff --git a/my_second_committed_file b/my_second_committed_file
index 095b9cd..c9887f8 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1,2 +1 @@
-Change1
-Change2
+Changed this file completely
john@akira:~/coderepo$
</PRE>

<P>
See how easy that is.  Note, the <TT>-</TT> is necessary to tell Git the following string is a path.  We no longer have the information for <TT>my_third_committed_file</TT> present in the output.  We have filtered everything out but the information we are looking for.  When you are up against deadlines, pouring through pages and pages of diffs and changes can be incredibly time consuming.  Having the tools available to cut that output down to just the relevant material can be life saving.

<P>

<H1><A NAME="SECTION00740000000000000000">
Day 4 - “Finding a good reference point”</A>
</H1>

<H2><A NAME="SECTION00741000000000000000">
Tag you're it!</A>
</H2>

<P>
During software development, a project will generally get to a point where it is ready to be released to people outside of the development team.  When this grand day occurs, it is crucial that both the developers and the users have a reference point with which to refer to the state of the code.  Having a code name or a version number means that within a very short period of time, both parties can converse about a problem, safe in the knowledge that they are on the same page.

<P>
In most version control systems, the word tagging is used to describe a reference point in the code's history.  A tag will usually refer to a single commit and labels that particular commit with a name that is easier to remember than a standard version number or SHA-1 hash.  The tag name used can be a codename, or a version number.  Often people will follow a simple numbering scheme, like <TT>v1.9</TT>.  

<P>
In this example, the <TT>1</TT> may refer to the major version number, and will denote a family of versions, often only changing a few times in a projects lifetime.  The <TT>9</TT> is a minor version number and can refer to a much more frequent release schedule.  You may also see textual items being appended to this version string, like <TT>rc</TT>, <TT>b</TT>, and <TT>a</TT>, denoting <SPAN  CLASS="textit">Release Candidate</SPAN>, <SPAN  CLASS="textit">Beta</SPAN> and <SPAN  CLASS="textit">Alpha</SPAN> respectively.

<P>

<DIV ALIGN="CENTER">
mybox = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
fancytitle =[fill=black, text=white]
<BR>
<IMG
 WIDTH="604" HEIGHT="421" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="\begin{tikzpicture}
\node [mybox] (box){%
\begin{minipage}{.9\textwidth}
The im...
...e, rounded corners] at (box.west) {\rotatebox{90}{Knowledge}};
\end{tikzpicture}">
</DIV>

<P>
Git implements tags in a very elegant way.  A tag is simply a label in Git that points to a single commit object.  The tag name can then be used in place of the SHA-1 to refer to a point in the repositories history.  Due to the simplicity of tags, it is also possible and very simple to tag a commit that occured way into the past.  Let us take a look at a simple tag example.  We will make the current point in the repository <TT>v1.0a</TT>.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git tag v1.0a
john@akira:~/coderepo$
</PRE>

<P>
On its own, this doesn't really tell us much, but running the following, shows us a little more information

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git rev-parse v1.0a
fa65f06cc62291bb0cd47aef9e05953d6655fc8e
john@akira:~/coderepo$
</PRE>

<P>
By running the <TT>git rev-parse</TT> with the tag name <TT>v1.0a</TT>, Git has returned us the SHA-1 hash of the commit we were referring to.  If we look back up at the earlier output, we can see that the most recent commit into the repository was indeed <SPAN  CLASS="textbf">fa65f06cc62291bb0cd47aef9e05953d6655fc8e</SPAN>.  To give us something to work with, let's tag the commit <SPAN  CLASS="textbf">e86dd...</SPAN> with the tage name <TT>v0.9</TT>.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git tag v0.9 e86dd
john@akira:~/coderepo$
</PRE>

<P>
Now, we can do the following;

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git diff v0.9..v1.0a
diff --git a/my_second_committed_file b/my_second_committed_file
index 3ad4cc3..c9887f8 100644
--- a/my_second_committed_file
+++ b/my_second_committed_file
@@ -1 +1 @@
-Change1
+Changed this file completely
diff --git a/my_third_committed_file b/my_third_committed_file
new file mode 100644
index 0000000..5d27866
--- /dev/null
+++ b/my_third_committed_file
@@ -0,0 +1 @@
+Addition to the line
john@akira:~/coderepo$
</PRE>

<P>
Notice that instead of using the dynamic reference HEAD, we have now used the tag names <TT>v0.9</TT> and <TT>v1.0a</TT> to refer to our previous commits and have returned the combined diff output of all the changes which occured between the two.

<P>

<DIV ALIGN="CENTER">
mybox = [draw=black, fill=gray!20, very thick, rectangle, rounded corners, inner sep=15pt, inner ysep=20pt]
fancytitle =[fill=black, text=white]
<BR>
<IMG
 WIDTH="251" HEIGHT="221" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="\begin{tikzpicture}
\node [mybox] (box){%
\begin{minipage}{.9\textwidth}
Tags a...
...ytitle, rounded corners] at (box.west) {\rotatebox{90}{Note}};
\end{tikzpicture}">
</DIV>

<P>

<H1><A NAME="SECTION00750000000000000000">
Day 5 - “Putting things back the way they were”</A>
</H1>

<H2><A NAME="SECTION00751000000000000000">
Revert, I say.  Revert!</A>
</H2>

<P>
Whilst working with your repository, something occurs quite often, is the need to go back in time, either temporarily or permanently, or even partially.  Git allows you to do this in a multitude of ways.  Let's see a real life situation where this need could arise.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“No, I don't have a copy of the file.  I was stupid and after I submitted it to you I er...it”.  
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John gave Michael the raised eyebrow look.  It wasn't the first time Michael had come to him with a similar problem.  Usually John would have had Michael go rooting through the archives to find it.  This time though, he wondered if Git might just come to the rescue.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Tell ya what Michael,” he grinned, “Since this isn't the first time you've come to me with this kind of predicament, why don't you go and find out how to use Git to get the file back.”  Michael sighed.  “I have tagged the repo each time we created an archive, so tell me what I need to run to extract it.”
</BLOCKQUOTE>
<P><BLOCKQUOTE>
<DIV ALIGN="CENTER">
* * * 

</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Man”, started Michael running over to John's desk forty five minutes later.  “I never knew there were so many ways to skin a cat”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Michael was a little out of shape and though he had only crossed a minor distance, he now stood there, leaned over John's desk ever so slightly out of breath.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, you learn much?” asked John.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Where d'ya want me to start?”
</BLOCKQUOTE>
<P>
<P>
Where exactly do we start?  Well one of the neat things about Git is that there are many ways to produce the same result.  While that may not seem like a benefit now, the trick is knowing just how to use each tool and what the benefit is of each method.  Right now, we are ready to look at four methods for achieving the task of viewing old information in the repository.  So how do we choose which method we wish to use?  We need to answer a few more questions before we are ready to decide.

<P>
The table below shows the three methods that we have access to now.  Note that this may not be a definitive list of methods, but that these can give us access to the data we need to view.  The columns are requirements or criteria.  We need to evaluate each command in order to determine which one is right for us.  Once you have been using Git a while, these kind of evaluations will become second nature to you, but right now, we will take a look at all available options, just to see what is out there.

<P>
<BR>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT">Method Name</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\rotatebox{90}{Alters Repository}$
 -->
<IMG
 WIDTH="136" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="\rotatebox{90}{Alters Repository}"></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\rotatebox{90}{Changes History}$
 -->
<IMG
 WIDTH="130" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="\rotatebox{90}{Changes History}"></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\rotatebox{90}{Alters Working Copy}$
 -->
<IMG
 WIDTH="165" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.png"
 ALT="\rotatebox{90}{Alters Working Copy}"></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\rotatebox{90}{Reversible}$
 -->
<IMG
 WIDTH="82" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="\rotatebox{90}{Reversible}"></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\rotatebox{90}{Multiple Files}$
 -->
<IMG
 WIDTH="1" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.png"
 ALT="\rotatebox{90}{Multiple Files}"></TD>
</TR>
<TR><TD ALIGN="LEFT">Reset</TD>
<TD ALIGN="LEFT">Possibly</TD>
<TD ALIGN="LEFT">Possibly</TD>
<TD ALIGN="LEFT">Possibly</TD>
<TD ALIGN="LEFT">Possibly</TD>
<TD ALIGN="LEFT">Yes</TD>
</TR>
<TR><TD ALIGN="LEFT">Checkout</TD>
<TD ALIGN="LEFT">No</TD>
<TD ALIGN="LEFT">No</TD>
<TD ALIGN="LEFT">Yes</TD>
<TD ALIGN="LEFT">No</TD>
<TD ALIGN="LEFT">Yes</TD>
</TR>
<TR><TD ALIGN="LEFT">Show</TD>
<TD ALIGN="LEFT">No</TD>
<TD ALIGN="LEFT">No</TD>
<TD ALIGN="LEFT">No</TD>
<TD ALIGN="LEFT">N/A</TD>
<TD ALIGN="LEFT">No</TD>
</TR>
</TABLE>
</DIV>
<BR>

<P>
Let's take a look at each of these in turn.  We are going to be covering two new commands and revisiting an old one.  Let us start with <TT>git reset</TT>.  We have already met this tool once.  When we used it previously, its purpose was to pull files out of the index that we were not ready to commit.  We were using <TT>git reset</TT> in its simplest state.  Actually Git can perform several other kinds of reset.  It should be noted here that using this can be quite dangerous as it can affect your index, your working copy, your branch and the pointer HEAD.  

<P>
In order to use <TT>git reset</TT> in any sane way to achieve our goal, we would need to look at branching, which at the moment, we are not ready to do.  In short <TT>git reset</TT> can drastically effect your working copy, affecting multiple files, and before we begin investigating, we really need to learn how to play in a safe environment.  

<P>
The next method on our list to discuss is the <TT>git checkout</TT> command.  This command can be used to bring back either a single file or multiple files and once again at this stage, is best employed in conjunction with branches.  At this point, you may be wondering why we are placing such emphasis on the use of branches.  As you will see next week, branches are incredibly powerful things, which allow you to experiment and play with your data, without the risk of losing anything.  <TT>git checkout</TT> will pull files from a previous commit into our working copy.  This is something remember.  If we have any changes in our working copy, the checkout will fail.

<P>
The last method we can use to view data which was in a previous commit, is the <TT>git show</TT> command.  This command literally pulls data from a previous version and dumps it to the standard output, a little like the <TT>cat</TT> command present in almost every single *nix environment.

<P>
Now that we have taken a quick look at our three methods, we must decide which one is going to be the most useful to us.  Looking at the scenario above, we can deduce that we really only need to pull out one file.  If our intention was to do large amounts of work on an old branch and pull many files from it, <TT>git reset</TT> may have been a good choice.  As we are looking for only a single file, we should consider looking at the checkout and show tools.

<P>
So now let us see how we can use <TT>git checkout</TT> to take one of our files back to the past.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status
# On branch master
nothing to commit (working directory clean)
john@akira:~/coderepo$ git checkout v0.9 -- my_second_committed_file
john@akira:~/coderepo$ cat my_second_committed_file 
Change1
john@akira:~/coderepo$ git checkout HEAD -- my_second_committed_file
john@akira:~/coderepo$ cat my_second_committed_file 
Changed this file completely
john@akira:~/coderepo$
</PRE>

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git status
# On branch master
nothing to commit (working directory clean)
john@akira:~/coderepo$ git checkout v0.9 -- my_second_committed_file
john@akira:~/coderepo$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#	modified:   my_second_committed_file
#
john@akira:~/coderepo$ git checkout HEAD -- my_second_committed_file
john@akira:~/coderepo$ git status
# On branch master
nothing to commit (working directory clean)
john@akira:~/coderepo$
</PRE>

<P>
Notice how we first checked that we didn't have any local modifications by running the <TT>git status</TT> command.  Then we are safe to run the <TT>git checkout</TT> command.  We used the <TT>v0.9</TT> tag from earlier to refer to an earlier commit state.  The next part of the command is the double hyphen (<TT>-</TT>) that tells Git that what comes after it is the path.  Finally we choose <TT>my_second_committed_file</TT> as the source file.  After this, when we <TT>cat</TT> the file, we see that it has changed to what it used to be in <TT>v0.9</TT>.

<P>
We then switch the file back to the latest version by using the <TT>HEAD</TT> reference.  Note that on the odd occasion, the <TT>HEAD</TT> reference doesn't always point to where you think it does, but this is an area we are yet to cover.  Then we run the command one more time, but this time we intersperse it with a <TT>git status</TT> to see that there are changes made to out local working copy.

<P>

<H2><A NAME="SECTION00752000000000000000">
Show me the money</A>
</H2>
The <TT>git show</TT> command will have largely the same effect, except it grabs us the data without having to change existing files in our working copy.  Let us view a quick example.

<P>
<PRE>[frame=leftline,framerule=1mm,fontsize=\relsize{-3}] 
john@akira:~/coderepo$ git show v0.9:my_second_committed_file
Change1
john@akira:~/coderepo$ git show v0.9:my_second_committed_file &gt; temp_file
john@akira:~/coderepo$ cat temp_file 
Change1
john@akira:~/coderepo$
</PRE>

<P>
The format of the <TT>git show</TT> command is rather similar to the checkout command we used a few moments ago.  The only difference is the presence of the colon, instead of the double hyphen.  Notice how the effect of the first command is just to print out the contents of the requested file to the screen.  With the Linux environment it is easy to pipe this output to a new file.  In the example above, we pipe the output using the <TT>&gt;</TT> character to the file called <TT>temp_file</TT>

<P>
Hopefully you can now see that there are often several ways to achieve the same result and it is important to ensure that you choose the right tool for the job.  The reset command was too dangerous to use, the checkout command modified our working copy, but the show tool allowed us to create a new file, guaranteeing that our working copy remained untouched.

<P><BLOCKQUOTE><SPAN  CLASS="textbf">In the trenches...
<BR>
<BR></SPAN>“So, if I am currently have changes to the file you want, in my local repository,” began John, “What command would you recommend I use?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Michael paused, clearly considering each method in his head.  The noise from the sandwich van's horn rang through the office and Michael immediately stood bolt upright and looked paniced.  “The van John” he stuttered, “The van”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“You can go to the van when you tell me which command I should use.”  John smirked.  Michael was one of the more junior members of the team and the managers often took the opportunity to haze him.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“I'm gonna go with git show,” he said in a rush.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Why?” asked John.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So you don't harm the working tree.” replied Michael smoothly, already walking out the door.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“You could have also branched,” shouted Rob, who was a few steps ahead of him.
</BLOCKQUOTE>
<P><BLOCKQUOTE>
<DIV ALIGN="CENTER">
* * *

</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“So, what's the status then John?” asked Markus.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>John pressed a button on his laptop and the slideshow on the screen advanced to show an organisational model.  “Well, we've not had a whole lot of time this week as the release for project Manta, but we've managed to look at logging and diffing, which is something that we really needed to cover.  Klaus also showed everyone how to tag things and went through our version numbering system again as several people had forgotten.”  Everyone in the room looked at Jack.  “We also found out about how to pull older versions out of the repository in a variety of ways.”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Markus looked pleased, “So, what's next?”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Klaus?” asked John.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Next, John put my team in charge of defining and teaching everyone about branching and merging.  This is the really important stuff.”  Klaus took over control of the laptop and clicked onto the next slide, which detailed a list of features.  “We really need to get a good handle on these topics to be successful.  It is key to collaboration”
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>“Well done team,” ended Markus, ”Wayne is going to be impressed with this.”
</BLOCKQUOTE>
<P>
<P>
We now have a good working knowledge of how to do many key things in Git.  Logging and diffing is supremely important for inspecting what changes have occurred in the repository.  Though the options here are not an exhaustive list, they should give you a basic understanding of how to use the tools.  It is well worth looking at the man pages for these commands to get an idea of just how expansive they can be.  For example, the diff tool can not only show you differences between your working copy and the index, but also between your index and the latest commit, using the <TT>cached</TT> option.

<P>
Next we move on to branching and merging.  Branching can be a tricky subject, so it is important to understand what is happening at the repository level.  It would be prudent to look over the After Hours section for Week 2 before continuing as some of the terminology may be a little confusing otherwise.

<P>

<P>

<H1><A NAME="SECTION00760000000000000000">
Summary - John's Notes</A>
</H1>

<H2><A NAME="SECTION00761000000000000000">
Commands</A>
</H2>

<UL>
<LI><TT>git log</TT> - Return a navigable list of commits to a repository

<P>
</LI>
<LI><TT>git log -S&lt;string&gt;</TT> - Show all commits that either introduced or removed a particular string from the repository

<P>
</LI>
<LI><TT>git log -S&lt;string&gt; &lt;path&gt;</TT> - Show all commits that either introduced or removed a particular string from the repository, but restrict the search to a specific path

<P>
</LI>
<LI><TT>git log HEAD&nbsp;1..HEAD</TT> - Show all commits between HEAD&nbsp;1 and HEAD, essentially the last commit

<P>
</LI>
<LI><TT>git diff HEAD&nbsp;1..HEAD</TT> - Show the actual differences between HEAD&nbsp;1 and HEAD

<P>
</LI>
<LI><TT>git tag &lt;name&gt;</TT> - Create a tag with the given name

<P>
</LI>
<LI><TT>git tag &lt;name&gt; &lt;commit&gt;</TT> - Retrospectively tag a commit with a given name

<P>
</LI>
<LI><TT>git rev-parse &lt;tag&gt;</TT> - Show the commit SHA-1 hash object referred to by the given name
</LI>
</UL>

<P>

<H2><A NAME="SECTION00762000000000000000">
Terminology</A>
</H2>

<UL>
<LI><SPAN  CLASS="textbf">Branch</SPAN> - A way of working on the same set of code in parallel without modifications overlapping

<P>
</LI>
<LI><SPAN  CLASS="textbf">Diff</SPAN> - Shows the actual differences between files

<P>
</LI>
<LI><SPAN  CLASS="textbf">Hunk</SPAN> - A section of a diff output
</LI>
</UL>

<P>

<H1><A NAME="SECTION00800000000000000000">
After Hours Week 3</A>
</H1>

<H1><A NAME="SECTION00810000000000000000">
“A Closer Look At Diffs”</A>
</H1>

<H2><A NAME="SECTION00811000000000000000">
Diff Algorithms</A>
</H2>

<P>
Talking about diff algorithms

<H1><A NAME="SECTION00900000000000000000">
Week 4</A>
</H1>

<H1><A NAME="SECTION00910000000000000000">
Day 1 - “Finally we're getting somewhere”</A>
</H1>

<H2><A NAME="SECTION00911000000000000000">
Planting trees</A>
</H2>

<P>
Parallel devving - ie...use both git and old for a while

<H1><A NAME="SECTION001000000000000000000">
Acknowledgements</A>
</H1>

<H1><A NAME="SECTION001010000000000000000">
“A Huge Thank You”</A>
</H1>

<P>

<H2><A NAME="SECTION001011000000000000000">
Proofing and Ideas</A>
</H2>
These people gave their time and effort to do forking and proofing, and giving marvelous suggestions about the book during development:

<P>
Og Maciel

<P>
Alistair Buxton

<P>
Miia Ranta (Myrtti)

<P>
Hassan Williamson (HazRPG)

<P>
(Synth_sam)

<P>

<H2><A NAME="SECTION001012000000000000000">
<SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> Support</A>
</H2>
These people provided invaluable <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> support:

<P>
Matthew Johnson

<P>
Ben Clifford

<P>

<H2><A NAME="SECTION001013000000000000000">
Git Support</A>
</H2>
#git on freenode.net

<P>
GitHub.com for hosting the Git repository of GITT

<P>
Wikipedia.org for providing information on the history of version control systems

<P>

<H1><A NAME="SECTION001100000000000000000">
About this document ...</A>
</H1>
 <STRONG>Git In the Trenches</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2008 (1.71)
<P>
Copyright © 1993, 1994, 1995, 1996,
Nikos Drakos, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright © 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-html 4.0,unicode,latin1,utf8 -split 2 gitt.tex</TT>
<P>
The translation was initiated by pete on 2011-03-09
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html5"
  HREF="gitt.html#SECTION00100000000000000000">Contents</A>
<LI><A NAME="tex2html6"
  HREF="gitt.html#SECTION00200000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html7"
  HREF="gitt.html#SECTION00210000000000000000">How this book works</A>
</UL>
<BR>
<LI><A NAME="tex2html8"
  HREF="gitt.html#SECTION00300000000000000000">Week 1</A>
<UL>
<LI><A NAME="tex2html9"
  HREF="gitt.html#SECTION00310000000000000000">Day 1 - ``Things need to change''</A>
<UL>
<LI><A NAME="tex2html10"
  HREF="gitt.html#SECTION00311000000000000000">Meeting the Team</A>
<LI><A NAME="tex2html11"
  HREF="gitt.html#SECTION00312000000000000000">The trouble with storage</A>
</UL>
<LI><A NAME="tex2html12"
  HREF="gitt.html#SECTION00320000000000000000">Day 3 - ``A possible solution''</A>
<UL>
<LI><A NAME="tex2html13"
  HREF="gitt.html#SECTION00321000000000000000">Version Control Nuances</A>
<LI><A NAME="tex2html14"
  HREF="gitt.html#SECTION00322000000000000000">Distributed Version Control</A>
<LI><A NAME="tex2html15"
  HREF="gitt.html#SECTION00323000000000000000">Branching</A>
<LI><A NAME="tex2html16"
  HREF="gitt.html#SECTION00324000000000000000">Staging</A>
<LI><A NAME="tex2html17"
  HREF="gitt.html#SECTION00325000000000000000">Workflow</A>
<UL>
<LI><A NAME="tex2html18"
  HREF="gitt.html#SECTION00325100000000000000">Centralised Workflow</A>
<LI><A NAME="tex2html19"
  HREF="gitt.html#SECTION00325200000000000000">Integration Manager Workflow</A>
<LI><A NAME="tex2html20"
  HREF="gitt.html#SECTION00325300000000000000">Dictator and Lieutenant Workflow</A>
</UL>
<LI><A NAME="tex2html21"
  HREF="gitt.html#SECTION00326000000000000000">Offline Committing</A>
<LI><A NAME="tex2html22"
  HREF="gitt.html#SECTION00327000000000000000">Developer Interaction</A>
<UL>
<LI><A NAME="tex2html23"
  HREF="gitt.html#SECTION00327100000000000000">Graphical User Interface Client (GUI)</A>
<LI><A NAME="tex2html24"
  HREF="gitt.html#SECTION00327200000000000000">Shell Extension Integration</A>
<LI><A NAME="tex2html25"
  HREF="gitt.html#SECTION00327300000000000000">Command Line Interface (CLI)</A>
</UL>
</UL>
<LI><A NAME="tex2html26"
  HREF="gitt.html#SECTION00330000000000000000">Day 4 - ``A decision is reached''</A>
<UL>
<LI><A NAME="tex2html27"
  HREF="gitt.html#SECTION00331000000000000000">Analysing Your Requirements</A>
</UL>
<LI><A NAME="tex2html28"
  HREF="gitt.html#SECTION00340000000000000000">Day 5 - ``Working like a team''</A>
<UL>
<LI><A NAME="tex2html29"
  HREF="gitt.html#SECTION00341000000000000000">Team Organisation</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html30"
  HREF="gitt.html#SECTION00400000000000000000">After Hours Week 1</A>
<UL>
<LI><A NAME="tex2html31"
  HREF="gitt.html#SECTION00410000000000000000">``History Lesson''</A>
<UL>
<LI><A NAME="tex2html32"
  HREF="gitt.html#SECTION00411000000000000000">A Brief History Of Version Control</A>
<UL>
<LI><A NAME="tex2html33"
  HREF="gitt.html#SECTION00411100000000000000">The Very Early Days</A>
<LI><A NAME="tex2html34"
  HREF="gitt.html#SECTION00411200000000000000">Time To Move On</A>
<LI><A NAME="tex2html35"
  HREF="gitt.html#SECTION00411300000000000000">Offering Commercial Support</A>
<LI><A NAME="tex2html36"
  HREF="gitt.html#SECTION00411400000000000000">The Millenium</A>
<LI><A NAME="tex2html37"
  HREF="gitt.html#SECTION00411500000000000000">Introducing the Linus Factor</A>
<LI><A NAME="tex2html38"
  HREF="gitt.html#SECTION00411600000000000000">Design Changes</A>
<LI><A NAME="tex2html39"
  HREF="gitt.html#SECTION00411700000000000000">Wrapping Up</A>
</UL>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html40"
  HREF="gitt.html#SECTION00500000000000000000">Week 2</A>
<UL>
<LI><A NAME="tex2html41"
  HREF="gitt.html#SECTION00510000000000000000">Day 1 - ``We are coders, we use Git!''</A>
<UL>
<LI><A NAME="tex2html42"
  HREF="gitt.html#SECTION00511000000000000000">Setting Up the Environment</A>
<LI><A NAME="tex2html43"
  HREF="gitt.html#SECTION00512000000000000000">Initialising A Repository</A>
</UL>
<LI><A NAME="tex2html44"
  HREF="gitt.html#SECTION00520000000000000000">Day 2 - ``Making commitments''</A>
<UL>
<LI><A NAME="tex2html45"
  HREF="gitt.html#SECTION00521000000000000000">Let's Make a Repository</A>
<LI><A NAME="tex2html46"
  HREF="gitt.html#SECTION00522000000000000000">Committing the Uncommitted</A>
</UL>
<LI><A NAME="tex2html47"
  HREF="gitt.html#SECTION00530000000000000000">Day 4 - ``Let's do this right, not fast''</A>
<UL>
<LI><A NAME="tex2html48"
  HREF="gitt.html#SECTION00531000000000000000">Uh-Oh I Think I Made A Mistake</A>
</UL>
<LI><A NAME="tex2html49"
  HREF="gitt.html#SECTION00540000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html50"
  HREF="gitt.html#SECTION00541000000000000000">Commands</A>
<LI><A NAME="tex2html51"
  HREF="gitt.html#SECTION00542000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html52"
  HREF="gitt.html#SECTION00600000000000000000">After Hours Week 2</A>
<UL>
<LI><A NAME="tex2html53"
  HREF="gitt.html#SECTION00610000000000000000">``A Litte Of Git's Internals''</A>
<UL>
<LI><A NAME="tex2html54"
  HREF="gitt.html#SECTION00611000000000000000">A Look At Plumbing</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html55"
  HREF="gitt.html#SECTION00700000000000000000">Week 3</A>
<UL>
<LI><A NAME="tex2html56"
  HREF="gitt.html#SECTION00710000000000000000">Day 1 - ``But how do I see what's going on?''</A>
<UL>
<LI><A NAME="tex2html57"
  HREF="gitt.html#SECTION00711000000000000000">Logging in Git</A>
</UL>
<LI><A NAME="tex2html58"
  HREF="gitt.html#SECTION00720000000000000000">Day 2 - ``But I need more information''</A>
<UL>
<LI><A NAME="tex2html59"
  HREF="gitt.html#SECTION00721000000000000000">Digging a little deeper</A>
</UL>
<LI><A NAME="tex2html60"
  HREF="gitt.html#SECTION00730000000000000000">Day 3 - ``What actually changed?''</A>
<UL>
<LI><A NAME="tex2html61"
  HREF="gitt.html#SECTION00731000000000000000">Doing the diff dance</A>
<LI><A NAME="tex2html62"
  HREF="gitt.html#SECTION00732000000000000000">Diffing Over A Range</A>
</UL>
<LI><A NAME="tex2html63"
  HREF="gitt.html#SECTION00740000000000000000">Day 4 - ``Finding a good reference point''</A>
<UL>
<LI><A NAME="tex2html64"
  HREF="gitt.html#SECTION00741000000000000000">Tag you're it!</A>
</UL>
<LI><A NAME="tex2html65"
  HREF="gitt.html#SECTION00750000000000000000">Day 5 - ``Putting things back the way they were''</A>
<UL>
<LI><A NAME="tex2html66"
  HREF="gitt.html#SECTION00751000000000000000">Revert, I say.  Revert!</A>
<LI><A NAME="tex2html67"
  HREF="gitt.html#SECTION00752000000000000000">Show me the money</A>
</UL>
<LI><A NAME="tex2html68"
  HREF="gitt.html#SECTION00760000000000000000">Summary - John's Notes</A>
<UL>
<LI><A NAME="tex2html69"
  HREF="gitt.html#SECTION00761000000000000000">Commands</A>
<LI><A NAME="tex2html70"
  HREF="gitt.html#SECTION00762000000000000000">Terminology</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html71"
  HREF="gitt.html#SECTION00800000000000000000">After Hours Week 3</A>
<UL>
<LI><A NAME="tex2html72"
  HREF="gitt.html#SECTION00810000000000000000">``A Closer Look At Diffs''</A>
<UL>
<LI><A NAME="tex2html73"
  HREF="gitt.html#SECTION00811000000000000000">Diff Algorithms</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html74"
  HREF="gitt.html#SECTION00900000000000000000">Week 4</A>
<UL>
<LI><A NAME="tex2html75"
  HREF="gitt.html#SECTION00910000000000000000">Day 1 - ``Finally we're getting somewhere''</A>
<UL>
<LI><A NAME="tex2html76"
  HREF="gitt.html#SECTION00911000000000000000">Planting trees</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html77"
  HREF="gitt.html#SECTION001000000000000000000">Acknowledgements</A>
<UL>
<LI><A NAME="tex2html78"
  HREF="gitt.html#SECTION001010000000000000000">``A Huge Thank You''</A>
<UL>
<LI><A NAME="tex2html79"
  HREF="gitt.html#SECTION001011000000000000000">Proofing and Ideas</A>
<LI><A NAME="tex2html80"
  HREF="gitt.html#SECTION001012000000000000000"><SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> Support</A>
<LI><A NAME="tex2html81"
  HREF="gitt.html#SECTION001013000000000000000">Git Support</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html82"
  HREF="gitt.html#SECTION001100000000000000000">About this document ...</A>
</UL>
<!--End of Table of Child-Links-->

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
pete
2011-03-09
</ADDRESS>
</BODY>
</HTML>
