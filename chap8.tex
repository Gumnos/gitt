% chap8.tex - Week 8
\cleardoublepage
%\phantomsection
\chapter{Week 8}

\section{Day 1 - ``Give a man a patch''}
\subsection{Collaborating with outsiders}

We have spoken at great length now about rebasing and have seen that it is a very very powerful tool.
It can form part of your workflow in your development cycle.
However, always heed that warning that should send alarm bells ringing in the back of your mind about rebasing.
Rebasing changes the past. Rebasing changes history.
As such, it should be used a) with caution, and b) only by people who understand exactly what they are doing.

We are going to leave rebasing for a while now, take a quick look at a feature you really should know about
and then focus on some of the more advanced features of Git.
The following situation occurs fairly regularly for some people.

\begin{trenches}
John was stroking his chin and looking pensively out of the window when Simon approached his desk.
The manager hadn't seen him yet and Simon instinctively swayed a little back and forth, try to make himself known in as subtle a way as possible.
Klaus, who was watching from the corner of his eye took a more direct approach.
He took the out of date org chart down from the office divider, screwed it up into a ball and launched it at John's head.
It struck the manager squarely in the jaw causing him to almost tip from his awkwardly balanced chair.

John noticed Simon standing there and looked a little surprised.
He then noticed Klaus and in an instant understood the chain of events that had just taken place.
``Sorry Simon,'' started John, ``I've been trying to figure out a problem all morning.''

``It's no problem.''  Simon pulled up a chair and sat down. ``I was wondering if you had a few minutes to discuss Luigi?''

\thoughtbreak

``Well as Luigi is a contractor, he's not going to get access to our repository here to perform commits directly.
And he doesn't have the capability, nor do I really want him, making our code available on the internet.
But he does have a clone of our repository from last week.'' John understood the problem.

``Right!''

``Have you heard of patching in Git?'' asked John.

Simon looked at his shoes, ``Can't say I have John, sorry.''  

John smiled, ``No worrys. What we can do is get Luigi to generate a patch of his changes.
We can then take that patch and apply it to our codebase.  Luigi can then just reset his clone when he comes into the office.''
Simon nodded as John continued, ``Go and ask Martha about it.  I think she's pretty hot on these types of things.''

Klaus giggled, ``Think she's hot eh John?''

The paper was returned.

\end{trenches}

It is a good question though. Sometimes you may have a repository that is either publically available, or made available to a group of people.
You do not necessarily want to set up a remote tracking branch and pull changes in from every single contributor.
There are two primary reasons for this;
\begin{enumerate}
\item There are a large number of people submitting small changes to the code.
\item There are difficulties in communicating between the two repositories either for security or general reasons.
\end{enumerate}

In these cases we need another way to apply changes from one branch into another.
Many larger open source projects allow contributors to email in patches.
Git does have some rather advanced ways of dealing with these types of scenarios.
We are going to scratch the surface and look at using three commands \texttt{git apply}, \texttt{git format-patch} and \texttt{git am}.

First, let us find a way of generating a patch.
Let us take the example we have currently in our repository.
Imagine that the \textbf{develop} branch exists on another computer in a clone of our repository.
At some point in time, someone cloned our repository.
They have the HEAD of our repository at the same point as we do, but they have continued to do some development in a new branch called \textbf{develop}.
Now they are ready to give those changes back.

Firstly we are going to look at using the \texttt{git diff} tool to generate a patch file which we can apply.

\begin{code}
john@satsuki:~/coderepo$ git checkout develop
Already on 'develop'
john@satsuki:~/coderepo$ git diff master develop
diff --git a/newfile2 b/newfile2
index 3545c1d..ff59f55 100644
--- a/newfile2
+++ b/newfile2
@@ -1,2 +1,3 @@
 Another new file
 and a new awesome feature
+newer dev work
diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
john@satsuki:~/coderepo$
\end{code}

That will generate us a diff from the \texttt{develop} to the \texttt{master} branch.
We could copy and paste that information from the terminal window into a file, but Linux offers us an easier way of doing this.

\begin{code}
john@satsuki:~/coderepo$ git diff master develop > our_patch.diff
john@satsuki:~/coderepo$ cat our_patch.diff 
diff --git a/newfile2 b/newfile2
index 3545c1d..ff59f55 100644
--- a/newfile2
+++ b/newfile2
@@ -1,2 +1,3 @@
 Another new file
 and a new awesome feature
+newer dev work
diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
john@satsuki:~/coderepo$
\end{code}

So we can see that the file itself has the information we are looking for.
Now we can use the \indexgit{apply} tool to actually modify the files in \textbf{master} and bring in the changes that have happened in \textbf{develop}.

\begin{code}
john@satsuki:~/coderepo$ git checkout master
Switched to branch 'master'
john@satsuki:~/coderepo$ git apply our_patch.diff
john@satsuki:~/coderepo$ git diff
diff --git a/newfile2 b/newfile2
index 3545c1d..ff59f55 100644
--- a/newfile2
+++ b/newfile2
@@ -1,2 +1,3 @@
 Another new file
 and a new awesome feature
+newer dev work
diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
john@satsuki:~/coderepo$ git commit -a -m 'Updated with patch'
[master 81eee9f] Updated with patch
 2 files changed, 2 insertions(+), 0 deletions(-)
john@satsuki:~/coderepo$ git diff develop master
john@satsuki:~/coderepo$
\end{code}

Of course doing things this way means that we still have to commit our changes.
Plus, all of the changes that we have made in the patch are committed in one block.
Sure, we could split that using some of the techniques in the After Hours sections, but then we may not always be aware of what should be split where.
