% chap8.tex - Week 8
\cleardoublepage
%\phantomsection
\chapter{Week 8}

\section{Day 1 - ``Give a man a patch''}
\subsection{Collaborating with outsiders}

We have spoken at great length now about rebasing and have seen that it is a very very powerful tool.
It can form part of your workflow in your development cycle.
However, always heed that warning that should send alarm bells ringing in the back of your mind about rebasing.
Rebasing changes the past. Rebasing changes history.
As such, it should be used a) with caution, and b) only by people who understand exactly what they are doing.

We are going to leave rebasing for a while now, take a quick look at a feature you really should know about
and then focus on some of the more advanced features of Git.
The following situation occurs fairly regularly for some people.

\begin{trenches}
John was stroking his chin and looking pensively out of the window when Simon approached his desk.
The manager hadn't seen him yet and Simon instinctively swayed a little back and forth, try to make himself known in as subtle a way as possible.
Klaus, who was watching from the corner of his eye took a more direct approach.
He took the out of date org chart down from the office divider, screwed it up into a ball and launched it at John's head.
It struck the manager squarely in the jaw causing him to almost tip from his awkwardly balanced chair.

John noticed Simon standing there and looked a little surprised.
He then noticed Klaus and in an instant understood the chain of events that had just taken place.
``Sorry Simon,'' started John, ``I've been trying to figure out a problem all morning.''

``It's no problem.''  Simon pulled up a chair and sat down. ``I was wondering if you had a few minutes to discuss Luigi?''

\thoughtbreak

``Well as Luigi is a contractor, he's not going to get access to our repository here to perform commits directly.
And he doesn't have the capability, nor do I really want him, making our code available on the internet.
But he does have a clone of our repository from last week.'' John understood the problem.

``Right!''

``Have you heard of patching in Git?'' asked John.

Simon looked at his shoes, ``Can't say I have John, sorry.''  

John smiled, ``No worrys. What we can do is get Luigi to generate a patch of his changes.
We can then take that patch and apply it to our codebase.  Luigi can then just reset his clone when he comes into the office.''
Simon nodded as John continued, ``Go and ask Martha about it.  I think she's pretty hot on these types of things.''

Klaus giggled, ``Think she's hot eh John?''

The paper was returned.

\end{trenches}

It is a good question though. Sometimes you may have a repository that is either publically available, or made available to a group of people.
You do not necessarily want to set up a remote tracking branch and pull changes in from every single contributor.
There are two primary reasons for this;
\begin{enumerate}
\item There are a large number of people submitting small changes to the code.
\item There are difficulties in communicating between the two repositories either for security or general reasons.
\end{enumerate}

In these cases we need another way to apply changes from one branch into another.
Many larger open source projects allow contributors to email in patches.
Git does have some rather advanced ways of dealing with these types of scenarios.
We are going to scratch the surface and look at using three commands \texttt{git apply}, \texttt{git format-patch} and \texttt{git am}.

First, let us find a way of generating a patch.
Let us take the example we have currently in our repository.
Imagine that the \textbf{develop} branch exists on another computer in a clone of our repository.
At some point in time, someone cloned our repository.
They have the HEAD of our repository at the same point as we do, but they have continued to do some development in a new branch called \textbf{develop}.
Now they are ready to give those changes back.

Firstly we are going to look at using the \texttt{git diff} tool to generate a patch file which we can apply.

\begin{code}
john@satsuki:~/coderepo$ git checkout develop
Already on 'develop'
john@satsuki:~/coderepo$ git diff master develop
diff --git a/newfile2 b/newfile2
index 3545c1d..ff59f55 100644
--- a/newfile2
+++ b/newfile2
@@ -1,2 +1,3 @@
 Another new file
 and a new awesome feature
+newer dev work
diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
john@satsuki:~/coderepo$
\end{code}

That will generate us a diff from the \texttt{develop} to the \texttt{master} branch.
We could copy and paste that information from the terminal window into a file, but Linux offers us an easier way of doing this.

\begin{code}
john@satsuki:~/coderepo$ git diff master develop > our_patch.diff
john@satsuki:~/coderepo$ cat our_patch.diff 
diff --git a/newfile2 b/newfile2
index 3545c1d..ff59f55 100644
--- a/newfile2
+++ b/newfile2
@@ -1,2 +1,3 @@
 Another new file
 and a new awesome feature
+newer dev work
diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
john@satsuki:~/coderepo$
\end{code}

So we can see that the file itself has the information we are looking for.
Now we can use the \indexgit{apply} tool to actually modify the files in \textbf{master} and bring in the changes that have happened in \textbf{develop}.

\begin{code}
john@satsuki:~/coderepo$ git checkout master
Switched to branch 'master'
john@satsuki:~/coderepo$ git apply our_patch.diff
john@satsuki:~/coderepo$ git diff
diff --git a/newfile2 b/newfile2
index 3545c1d..ff59f55 100644
--- a/newfile2
+++ b/newfile2
@@ -1,2 +1,3 @@
 Another new file
 and a new awesome feature
+newer dev work
diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
john@satsuki:~/coderepo$ git commit -a -m 'Updated with patch'
[master 81eee9f] Updated with patch
 2 files changed, 2 insertions(+), 0 deletions(-)
john@satsuki:~/coderepo$ git diff develop master
john@satsuki:~/coderepo$
\end{code}

Of course doing things this way means that we still have to commit our changes.
Plus, all of the changes that we have made in the patch are committed in one block.
Sure, we could split that using some of the techniques in the After Hours sections, but then we may not always be aware of what should be split where.

\subsection{Can we have some order please?}

There is another tool that can come to our rescue here.
It is primarily used for working with \index{mbox} mailboxes, but it also has some other uses which we will describe here.
Would it not be nice to be able to have each commit that we want to use as a patch in a separate patch file.
The file \texttt{our\_patch.diff} above contained two commits worth of data.
We have access to another tool in our fight against disparate systems.
This is the \indexgit{git format-patch} command.

First we will undo the changes we made previously by resetting the \textbf{master} branch back to its older position and deleting the \texttt{our\_patch.diff} file.

\begin{code}
john@satsuki:~/coderepo$ git reflog show master -n 4
81eee9f master@{0}: commit: Updated with patch
f8d5100 master@{1}: commit: Finished new dev
1968324 master@{2}: commit: Start new dev
john@satsuki:~/coderepo$ git reset --hard f8d5100
HEAD is now at f8d5100 Finished new dev
john@satsuki:~/coderepo$ rm our_patch.diff
john@satsuki:~/coderepo$
\end{code}

We used the \texttt{git reflog} command to show what the last four \textbf{master} HEAD values were.
Then we reset the branch back to the point before the \texttt{git apply}.
Finally we deleted the patch.
Now let us see how to use the \texttt{git format-patch} command to create multiple patch files.

\begin{code}
john@satsuki:~/coderepo$ git format-patch master..develop
0001-Some-new-dev-work.patch
0002-More-new-deving.patch
john@satsuki:~/coderepo$
\end{code}

It would appear that the result of this command is that two files have been generated.
Let us confirm our suspicions and \texttt{cat} the contents of them to ensure that they contain the data we expect.

\begin{code}
john@satsuki:~/coderepo$ cat 0001-Some-new-dev-work.patch 
From af3c6d730a8632d99b5626a7c0e921d14af21f50 Mon Sep 17 00:00:00 2001
From: John Haskins <john.haskins@tamagoyakiinc.koala>
Date: Thu, 7 Jul 2011 19:01:59 +0100
Subject: [PATCH 1/2] Some new dev work

---
 newfile3 |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/newfile3 b/newfile3
index 638113c..2e00739 100644
--- a/newfile3
+++ b/newfile3
@@ -1 +1,2 @@
 These changes are in the origin
+new dev work
-- 
1.7.4.1

john@satsuki:~/coderepo$
\end{code}

Woah! Hold on a minute. This does not seem to be a normal diff file at all.
In fact, that is absolutely right. This is a patch file and the two are not the same.
The patch file contains much more information than the simple diff file.
For a start we get information about which commit this patch came from, who created it, when and a subject.
In fact this looks almost like an email.  In fact it is created to resemble a format that would be easily emailable.

We have specified a range of commits to the \texttt{git format-patch} command with the parameter \texttt{master..develop}.
The format of that parameter should be familar from earlier chapters when we utilised it for commands like \texttt{git diff} and \texttt{git log}.
We could now take those files, email them to someone else and they could apply them.
Let us learn one more tool, and see how we would apply those patches when they had been received at the other end.

\begin{code}
john@satsuki:~/coderepo$ git am 0001-Some-new-dev-work.patch
Applying: Some new dev work
john@satsuki:~/coderepo$ git am 0002-More-new-deving.patch
Applying: More new deving
john@satsuki:~/coderepo$ git diff master..develop
john@satsuki:~/coderepo$
\end{code}

Of course this is just a simple example case and in actual usage there may be cases where conflicts and other complications occur.
Looking at a log output, we can see that the original dates and times of the commits are maintained and are not updated.
We can ignore this if we wish and use the \texttt{--ignore-date} parameter to use the current date when committing the patch to the repository.

\begin{code}
john@satsuki:~/coderepo$ git log -n4
commit 30900fe1b7e72411dabab8b02070f36e2431f704
Author: John Haskins <john.haskins@tamagoyakiinc.koala>
Date:   Thu Jul 7 19:02:15 2011 +0100

    More new deving

commit a8281fb589e36389cc8cb0da7ebee225b4d1adfc
Author: John Haskins <john.haskins@tamagoyakiinc.koala>
Date:   Thu Jul 7 19:01:59 2011 +0100

    Some new dev work

commit f8d5100142b43ffaba9bbd539ba4fd92af79bf0e
Author: John Haskins <john.haskins@tamagoyakiinc.koala>
Date:   Thu Jul 7 08:39:29 2011 +0100

    Finished new dev

commit 1968324ce2899883fca76bc25496bcf2b15e7011
Author: John Haskins <john.haskins@tamagoyakiinc.koala>
Date:   Thu Jul 7 08:39:07 2011 +0100

    Start new dev
john@satsuki:~/coderepo$
\end{code}

Interestingly if we use our alias for the log command we see something maybe a little unexpected.

\begin{code}
john@satsuki:~/coderepo$ git logg -n6
* 30900fe (HEAD, master) More new deving
* a8281fb Some new dev work
| * aed985c (develop) More new deving
| * af3c6d7 Some new dev work
|/  
* f8d5100 Finished new dev
* 1968324 Start new dev
john@satsuki:~/coderepo$ 
\end{code}

Notice that the branch \textbf{master} has not been simply fast forwarded to that of commit of \textbf{develop}.
This is because we have not performed a merge, but in a sense we have manually made that changes to the files and created separate commits for them.
In this way the commits \textbf{30900fe} and \textbf{a8281fb} are not the same as their \textbf{develop} counterparts.

If you intend to use this workflow, it is worth spending some time reading the man page for \texttt{git am} and \texttt{git format-patch} as both of them hold valuable information regarding the customisation and handling of patches and emails.
Tamagoyaki Inc. are not going to use this workflow often and so just applying a few patches here and there from contractors using the methods is prefectly acceptable to them.
If you were a large open source establishment, or any company that accepts a large number of patches, you may want to take a closer look at how to work these.
Now it is time to move on to some more advanced topics within Git, but first a little cleanup.

\begin{code}
john@satsuki:~/coderepo$ rm 0001-Some-new-dev-work.patch 
john@satsuki:~/coderepo$ rm 0002-More-new-deving.patch 
john@satsuki:~/coderepo$
\end{code}

\section{Day 2 - ``Looking for problems''}
\subsection{A problem shared is a problem bisected}

During most software development, bugs are introduced.
Sometimes these bugs are fixed immediately and sometimes they sit there in the code festering away for months on end until someone tests a specific case.
Of course it is always best to have test suites and run them regularly against the code base, but on occasions either the test case itself has a bug,
or the test case is written in such a way that a particular bug would never present itself.
Tamagoyaki Inc. have a fairly rigorous testing procedure.
Unfortunately it would seem that one particularly nasty bug has slipped through the cracks.
Cue a difficult discussion.

\begin{trenches}
``But what I don't understand John, is that you now know what happened at every step in the process.
How can something like this break and you not know about it?''
As always Markus was getting snappy and as always John was having to bite his lip.

``It's not a question about not knowing about it,'' begain John, ``The difficulty is knowing what change introduced the problem.
We are on such a rapid development schedule that too many things are changing at once.''

``Well, this is one of the reasons you guys have spent the last two months getting this version control system running.''
Markus got up and opened the door.  ``I suggest you fix it.''

\thoughtbreak

``Markus is blaming us for introducing a bug?'' Rob was pretty shocked as he and Simon chatted at the water cooler.

``More like, Markus believed that a version control system was going to solve all of our problems,'' replied Simon.

Rob squinted his face up as a car drove into the buildings car park, showering the room with reflected sunlight.
He shielded his eyes. ``You know I heard there was a tool in Git for helping to find bugs.
Think I may take a look over lunch, you know, be a real hero.''

They both chuckled.
\end{trenches}

It is true that Git does have a very powerful tool for helping to detect revisions that introduced bugs into the system.
The tool is called \indexgit{bisect} and it is used to successively checkout revisions from the repository,
check them to see if the bug is present and then use that information to determine the revision that is most likely to have introduced the bug.

Let us assume that the bug in our repository is a fairly simple one.
For some bizarre reason our codebase is broken unless the word \texttt{Addition} is present in one of the files.
If we run a simple Linux \texttt{grep} command across the files, we can see that the word we are after is not there.
However, if we go back to tag \textbf{v1.0a} and run the same command, we can see that the word is there.

\begin{code}
john@satsuki:~/coderepo$ grep "Addition" *
john@satsuki:~/coderepo$ 
john@satsuki:~/coderepo$ git checkout v1.0a 
Note: checking out 'v1.0a'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

HEAD is now at a022d4d... Messed with a few files
john@satsuki:~/coderepo$ grep "Addition" *
my_third_committed_file:Addition to the line
john@satsuki:~/coderepo$ 
\end{code}

Notice the warning about checking out a non-branch.
This is perfectly normal and should not worry you but please be aware that it is obviously best to have a clean working directory before starting any type of \texttt{bisect} commands.
We can see that the string we are looking for is present in the file called \texttt{my\_third\_committed\_file}.
As our repository is very small, it would not take us long to go through and check each revision to see when this string was deleted.
In fact we have other tools available to search for the adding and removal of strings.
For now let us assume that the \emph{bug} is more complicated than this.

Let us go back to the facts.
We know that the repository was \textbf{good} at tag \textbf{v1.0a}.
We also know that the repository is bad in its current state.
By feeding these details to the \texttt{git bisect} command, we can begin a search for the bug.
What will happen at each stage is that Git will checkout a revision that it wants us to test and we tell Git if we think that revision is good or bad.

\begin{code}
john@satsuki:~/coderepo$ git bisect start
Already on 'master'
john@satsuki:~/coderepo$ git bisect good v1.0a
john@satsuki:~/coderepo$ git bisect bad master
Bisecting: 9 revisions left to test after this (roughly 3 steps)
[ed2301ba223a63a5a930b536a043444e019460a7] Removed third file
john@satsuki:~/coderepo$
\end{code}

So we invoke the tool by running \texttt{git bisect start}.
After this we tell Git the things that we know. It was good at \textbf{v1.0a}, \texttt{git bisect good v1.0a}.
However, it was bad at \textbf{master}, our current revision, \texttt{git bisect bad master}.
After this, Git checks out revision \textbf{ed2301b} and tells us that there are \texttt{9} revisions between the two points and that it should take only \texttt{3} more steps to complete.
Now we run our test again.

\begin{code}
john@satsuki:~/coderepo$ grep "Addition" *
john@satsuki:~/coderepo$
\end{code}

As we have no result here, this would be classed as a bad revision and so we mark it as so.

\begin{code}
john@satsuki:~/coderepo$ git bisect bad
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[9710177657ae00665ca8f8027b17314346a5b1c4] Added another file
john@satsuki:~/coderepo$
\end{code}

Git now presents us with a new choice and you can see that the number of revisions left to check has decreased dramatically from \texttt{9} to \texttt{3}.
We continue marking our revisions as good and bad.

\begin{code}
john@satsuki:~/coderepo$ grep "Addition" *
my_third_committed_file:Addition to the line
john@satsuki:~/coderepo$ git bisect good
Bisecting: 2 revisions left to test after this (roughly 1 step)
[cfbecabb031696a217b77b0e1285f2d5fc2ea2a3] Fantastic new feature
john@satsuki:~/coderepo$ grep "Addition" *
my_third_committed_file:Addition to the line
john@satsuki:~/coderepo$ git bisect good
Bisecting: 0 revisions left to test after this (roughly 1 step)
[b119573f4508514c55e1c4e3bebec0ab3667d071] Merge branch 'wonderful'
john@satsuki:~/coderepo$ grep "Addition" *
my_third_committed_file:Addition to the line
john@satsuki:~/coderepo$ git bisect good
ed2301ba223a63a5a930b536a043444e019460a7 is the first bad commit
commit ed2301ba223a63a5a930b536a043444e019460a7
Author: John Haskins <john.haskins@tamagoyakiinc.koala>
Date:   Fri Apr 1 07:37:34 2011 +0100

    Removed third file

:100644 000000 68365cc0e5909dc366d31febf5ba94a3268751c6 0000000000000000000000000000000000000000 D	my_third_committed_file
john@satsuki:~/coderepo$ 
\end{code}

Oh! Something different.  Git has actually finished the bisect and has suggested to us that this commit was responsible for introducing the bug in our code.
If we look at the comment it was in this revision that we removed a particular file.
This file was the one that contained our special \texttt{Addition} string.
Git was right! We screwed up then.  At this point we can go back to our \textbf{master} branch and decide what to do about it.

\begin{code}
john@satsuki:~/coderepo$ git branch -v
* (no branch) b119573 Merge branch 'wonderful'
  develop     aed985c More new deving
  master      30900fe More new deving
  wonderful   4d91aab Updated another file again
  zaney       7cc32db Made another awesome change
john@satsuki:~/coderepo$ git checkout master
Previous HEAD position was b119573... Merge branch 'wonderful'
Switched to branch 'master'
john@satsuki:~/coderepo$
\end{code}

Notice that at the end of the bisect, Git does not return us to the master branch.
We are left in the last tested checked out revision.


\subsection{Automating the process}
So bisecting is a very powerful way of quickly and efficiently finding the point at which bugs were introduced or \index{regression testing}regression testing.
Git was spot on when it suggested that that revision was the one responsible for the mistake.
Sometimes you may not be able to test a revision that Git checks out for you for other reasons.
In this case you can always run \texttt{git bisect skip} to skip that revision.
It is all very well being able to run this at each revision Git asks us to but to be honest, if you have 30-40 steps to test and you have to compile code to see if the bug is present it can get a little bit boring.

Git has a way of allowing us to test automatically.
The example we are going to use is obviously based on a Linux environment, but if you are a developer on a Windows platform, you should have no trouble understanding what is happening here.
We are going to create a small shell script that will automatically run our grep test.
If the string is found we will exit with a status code of \texttt{0}, indicating that it was successful and if
the string is not found, we will exit with a status code of \texttt{123}, indicating that the test was unsuccessful.

Git will use these status codes and interpret a code of \texttt{0} as \textbf{good} and a code of \texttt{123} as \textbf{bad}.
Below is a copy of our shell script which we have saved as \texttt{test.sh} and have given relevant permissions to allow it to run etc.
Notice we have had to exclude our \texttt{test.sh} file from the test, else the string \texttt{Addition} would have been found there.

\begin{code}
john@satsuki:~/coderepo$ cat test.sh 
#!/bin/bash

if grep -q Addition * --exclude=test.sh
  then echo "Good"
  exit 0
else 
  echo "Bad"
  exit 123
fi
john@satsuki:~/coderepo$ 
\end{code}

Now we invoke \texttt{git bisect} slightly differently by asking it to start and itterate over the revisions \texttt{master} to \texttt{v1.0a}.
At this point we have not told Git anything about which revisions are good or bad.

\begin{code}
john@satsuki:~/coderepo$ git bisect start master v1.0a
Bisecting: 9 revisions left to test after this (roughly 3 steps)
[ed2301ba223a63a5a930b536a043444e019460a7] Removed third file
john@satsuki:~/coderepo$
\end{code}

Now we ask Git to continue testing, but to run our script at each iteration to determine the success or failure of each checked out revision.

\begin{code}
john@satsuki:~/coderepo$ git bisect run sh ./test.sh
running sh ./test.sh
Bad
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[9710177657ae00665ca8f8027b17314346a5b1c4] Added another file
running sh ./test.sh
Good
Bisecting: 2 revisions left to test after this (roughly 1 step)
[cfbecabb031696a217b77b0e1285f2d5fc2ea2a3] Fantastic new feature
running sh ./test.sh
Good
Bisecting: 0 revisions left to test after this (roughly 1 step)
[b119573f4508514c55e1c4e3bebec0ab3667d071] Merge branch 'wonderful'
running sh ./test.sh
Good
ed2301ba223a63a5a930b536a043444e019460a7 is the first bad commit
commit ed2301ba223a63a5a930b536a043444e019460a7
Author: John Haskins <john.haskins@tamagoyakiinc.koala>
Date:   Fri Apr 1 07:37:34 2011 +0100

    Removed third file

:100644 000000 68365cc0e5909dc366d31febf5ba94a3268751c6 0000000000000000000000000000000000000000 D	my_third_committed_file
bisect run success
john@satsuki:~/coderepo$ 
\end{code}

The parameters after the \texttt{git bisect run} tell Git which command we wish to run at each stage.
In our case it is \texttt{sh ./test.sh}.
You can see Git invoking our \texttt{test.sh} script in each case, and the result of our script, either \texttt{Good} or \texttt{Bad} depending on which was echoed from the result of the grep test.
Git has arrived at exactly the same result, but we have had to do nothing other than write a small script.
For larger tests, this would have saved us a large amount of work.

\begin{trenches}
``Simon could I have a word?'' It was Rob and he wasn't looking happy.

Simon turned to him and grinned, ``Sure buddy what's up?''  His face dropped when he saw Rob's expression.

``I think we'd better go grab the meeting room.''

Simon looked confused.

``I used the bisect tool to find the bug.  But you're not gonna like what I found.''

\thoughtbreak

``Simon how could you have done that?'' John was asking the questions and they were coming thick and fast.
``I mean changing the API key for the web sevice whilst developing was not a great idea to start with, but committing that to the repository was rediculous.''
Simon sat there with his head in his hands.
``You know how secret that API key is right?'' Simon nodded.
``Simon we were supposed to be releasing this repository publically in a few weeks but now that the API is in there we can't do that.''

``John I'm really sorry OK.'' Simon was kicking himself for his mistake.

John sighed, he had been really angry to begin with but now he was calming down,
``It's OK Simon, we're all getting used to the repository and version control.  Do you think we can fix it?''
\end{trenches}

\section{Day 3 - ``Filtered repos''}
\subsection{Looking at a repo with rose tinted glasses}

It does happen. Sometimes when people are under pressure, mistakes are made, just like earlier when we accidently deleted our branch from the repository.
This time the mistake is a little more crucial but again it does happen and it sometimes goes a long time before it is noticed.

\begin{trenches}
``So it's been in there for how long?'' asked John.

Simon looked pretty sheepish as he mouthed the words, ``Weeks.''

John bit on the end of the pen in his hand.
His teeth chewed into the plastic, deforming the blue lid.
``Did you find a way of sorting it out yet?''

``I think so. It's not ideal, but I think so.''
\end{trenches}



submodule
subtree
filter branch

\clearpage

\section{Summary - John's Notes}
\subsection{Commands}
\begin{itemize}

\item\texttt{git rebase -i HEAD~3} - Runs the rebase tool interactively for the last three commits

\item\texttt{git rebase <branchA> <branchB>} - Lift all commits between the common ancestor of branchA and branchB and replay them on top of branchB

\item\texttt{git branch <branch\_name> <startpoint>} - Create a new branch starting from a definte start point

\item\texttt{git rebase --onto master <branchC> \newline <branchA> <branchB>} - Lift all commits between the common ancestor of branchA and branchB and replay them on top of branchC
\end{itemize}

\subsection{Terminology}
\begin{itemize}
\index{Terminology!SSH}\item\textbf{SSH} - A type of secure network protocol
\index{Terminology!HTTP}\item\textbf{HTTP} - The protocol that is used to serve internet pages
\index{Terminology!Rebase}\item\textbf{Rebase} - Used primarily for lifting commits and reapplying them to another base branch
\end{itemize}
