% chap7.tex - Week 7
\cleardoublepage
%\phantomsection
\chapter{Week 7}

How to collab, pushing, rebasing, merging, patches

\section{Day 1 - ``Networking with a difference''}
\subsection{Pushing across a LAN}

Now we have a complete copy of our repository in another location.  At the moment we have created this clone on the same machine that our original is.  This isn't really a very good idea for backup purposes.  Git supplies several means with which to talk to a remote machine, but by far the most common of these is to utilise the SSH protocol.  SSH is a secure, encrypted way to communicate with a remote repository.  Which is a must for pushing to an important repository that people are going to pull information from.

If we assume that for a moment that our user \emph{john} has now moved to another machine and now wishes to clone a repository that he had on his original machine to this new one.  The commands are identical to that which we used before.  We are going to assume that \emph{john} already has SSH access to the machine.  In this way, we can issue the commands as follows.

\begin{Verbatim}
john@akira:~$ git clone ssh://john@satsuki/home/john/coderepo coderepo-ne
Initialized empty Git repository in /home/john/coderepo-ne/.git/
john@akira's password: 
remote: Counting objects: 53, done.
remote: Compressing objects: 100% (36/36), done.
Receiving objects: 100% (53/53), 4.84 KiB, done.
Resolving deltas: 100% (10/10), done.
remote: Total 53 (delta 10), reused 0 (delta 0)
john@akira:~$ 
\end{Verbatim}

Now we have done exactly as before and cloned our repository to a local folder called \texttt{coderepo-ne} from the remote url \texttt{ssh://john@satsuki/home/john/coderepo}.  Notice the use of \texttt{ssh://} to denote the specification of the SSH protocol.  We have also put the users name in the url of the remote path.  If the SSH server was running on a different port to usual, that is, on a port other than 22, we could have also added a port number preceeded by a colon after the hostname.

SSH isn't the only protocol that Git can use.  We have already looked at two; local and SSH.  In fact, Git supports a further two protocols and these are HTTP/S and Git's own GIT protocol.  We are going to take a quick look at the Git protocol next, before moving on to HTTP/S.

\subsection{The Git Protocol}
The GIT protocol is the fastest transfer protocol out there for Git repositories.  This should come as no surprise, since it was developed exclusively for use within a Git environment.  It does however have a relatively large drawback.  The drawback is that it provides absolutely no authentication.  For this reason, enabling the GIT protocol on a repository and running the server backend, (described later), will allow anyone who can talk to the servers port complete read access to the repository.

If you are serving a large repository on the Internet for example, this could actually be rather beneficial and will allow you to serve pulls quickly and efficiently.  However, though it is possible to enable \emph{pushing} using the GIT protocol, the lack of security would mean that anyone who could see the server and connect to the port, usually 9418, could make changes to the repository.  This is usually entirely undesirable and as such people will often couple a read-only GIT protocol with a writable SSH protocol for the developers that need push access.

\subsection{The HTTP/S Protocol}
Just as with the GIT protocol, Git can support the HTTP/HTTPS protocol as well.  Setting up this is usually as simple as creating a bare clone of your repository, keeping it up to date, usually via a post-update-hook, which is described later in the book, and simply allowing clients access to this server area.  

Note that the above is only to provide read-only access over HTTP.  It is possible to allow writable access, ie pushing, over HTTPS, but this is more complicated to set up and is outside the scope of this book.

\subsection{Protocol decision}
Tamagoyaki are about to embark on their decision making process regarding which protocols to use and how to perform their collaboration between themselves and their external partners.  They are going to have to take multiple things into consideration, such as security, speed, administration and storage.  When you begin to implement the Git system yourself, you too will have to think about these decisions and answer questions like:

\begin{itemize}
\item Who is going to require access to the repository?
\item How many people are going to require access to the repository?
\item Is the information sensitive, either from an IP perspective or from a customer point of view?
\item How large is the data that we are hosting?
\item How large is the change set?
\item Do we need a QA area?
\item Do we need a Production area?
\end{itemize}

This is just a short list of the questions that you will need to consider when implementing a full on Git environment.  The beauty of the Git system though, is that it is flexible and very difficult to box yourself into a corner, where a decision made early on prohibits a different approach later on.

\section{Day 2 - ``Now let's work together''}
\subsection{Pure collaboration}

We are now armed with a much clearer idea of how Git works and indeed we are now in a position to actually implement the developmental model that the team of Tamagoyaki need in order to collaborate on their projects.  It should be noted that although we have reached the point of being able to work together on a project, this is not where out discussions about Git will end.  We still have a number of topics to cover and these will be visited as required during the subsequent implementation of Git at Tamagoyaki.

\begin{trenches}
``So I still maintain that we follow the original plan,'' said Rob.  ``Each person has their own repository and is the master of their own commits''

John shook his head.  ``On a small scale,'' he began, ``that might work.''  He paused for a breath.  "But we need to think about scalability too.  Whilst I don't think all development work should be in one repository, I also don't think the best way to go is to have a repo for every person.''

``I know it's a rarity, but I gotta agree with John.''  Klaus spoke whilst idly stabbing his pen lighty into a blob of what looked like modelling clay.  ``Think what the chimp would say to it too.''

Martha furrowed her brow, ``The chimp?'' she asked.

John turned to look at Martha and almost regretted having to inform her of yet another of Klaus' pet names.  ``That's what Klaus calls Jimmy in IT.''  

Martha looked a little horrified, ``Klaus, that's an awful thing to say.''  

``What?  He spends all day monkeying around in the 'datacenter'.  I've never really seen him do any work at all.''  Klaus was looking at Martha now with one eyebrow raised.  He had used airquotes when voicing the word 'datacenter'.  ``Plus he calls it a datacenter, but I've seen inside, it's more like a cupboard with a PC in it.''

``You need to show a little more respect Klaus,'' Martha threw back, a little more agressively than she had intended.

``Guys!! Guys!!''  John shouted.  ``Can we get back to the topic at hand and deal with Klaus later?''

The room fell silent for a while, until the comments had transitioned for immediate to short term memory.  ``How about doing it by team?''  It was Eugene.  ``You know, kinda like a Mob repository.  Each team will have their own repository and the branches inside will belong to the different team members and be named accordingly so.  Then we would have a company repository which would hold the projects and would have dev, qa and released branches.''

``You know that's not a bad idea Eugene.''  Klaus said, trying to redeem himself.  ``You da man.  How about a hi-five.''

\end{trenches}

The idea of having a Mob repository 
